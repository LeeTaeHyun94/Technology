# [Engineer Information Processing]



# 1. Database

- Tuple : 테이블에서 행에 해당된다.
- 속성 (Attribute) :  데이터의 가장 작은 논리적 단위로서 파일 구조 상의 데이터 항목 또는 데이터 필드에 해당한다.


- Relation : Relation Schema와 Relation Instance로 구성된다. 
  - 튜플은 서로 다른 값을 갖는다.
  - 모든 속성값은 논리적으로 더 이상 분해할 수 없는 원자 값이어야 한다.
  - 각 속성은 릴레이션 내에서 유일한 이름을 갖는다.
  - 하나의 릴레이션에서 튜플의 순서는 없다.
- Domain : 속성이 취할 수 있는 값들의 집합
- 즉각 갱신 기법 : 데이터베이스 로그를 필요로 하는 회복 기법
- 정규화의 목적
  - 어떠한 Relation이라도 데이터베이스 내에서 표현 가능하게 만든다.
  - 데이터 삽입 시 Relation을 재구성할 필요성을 줄인다.
  - 중복을 배제하여 삽입, 삭제, 갱신 이상 발생을 방지한다.
  - 효과적인 검색 알고리즘을 생성할 수 있다.



- 제 1 정규형 : Relation의 Domain들의 값이 원자 값만을 갖는다.
- 제 2 정규형 : 제 1 정규형을 만족하면서 키가 아닌 모든 기본 키에 완전 함수 종속이다.
- 제 3 정규형 : 제 2 정규형을 만족하면서 키가 아닌 모든 속성들이 기본 키에 이행적으로 함수 종속되지 않는다.
- BCNF(Boyce-Codd Normal Form) : 제 3 정규형에서 결정자이면서 후보 키가 아닌 것을 제거한 Relation
   - BCNF에 속하는 릴레이션은 반드시 제 3 정규형 (역은 성립하지 않는다.)
     - 복합 속성을 허용한다.
- 제 4 정규형 : 함수 종속이 아닌 다치 종속(Multivalued Dependency)이 제거된다.
- 제 5 정규형 : 제 4 정규형을 일반화한 것으로 모든 조인의 함수 종속이 관계의 후보 키를 통해서만 만족된다.

   - R. 페이건이 도입하였다.
   - 모든 결합 종속성(Join Dependency)이 관계의 후보 키만으로 논리적으로 함축되어 있다.



- 논리적 데이터 독립성 :  개별 사용자나 응용 프로그램의 데이터의 관점을 변경하지 않고 전체 데이터베이스의 논리적 구조를 변경시킬 수 있는 능력



- 물리적 데이터 독립성 : 응용 프로그램과 물리적 저장 장치를 독립시킴으로써, 기존 응용 프로그램에 영향을 주지 않고 데이터의 물리적인 구조를 변경시킬 수 있는 능력





- 한 릴레이션에서 속성의 개수는 Degree (차수), Tuple (튜플)의 개수는 Cardinality




- 해싱 함수
  - 기법
    - 제산법 : 나머지 연산자를 이용해 주소로 사용한다.
    - 중첩(폴딩)법 :  Record Key를 여러 부분으로 나누고, 나눈 부분의 각 숫자를 더하거나 XOR한 값을 주소로 사용한다.
    - 기수 변환법 : Key 값을 다른 진법으로 변환해 초과길이는 잘라서 주소로 사용한다.
    - 숫자 분석법 : 각 숫자의 분포를 이용해서 균등한 분포의 숫자를 선택해서 주소로 사용한다.
    - 제곱법 : 키 값을 제곱한 후에 중간의 몇 자리를 선택하고 그 중간 값을 주소로 사용한다.
    - 무작위 방법 : 난수를 발생, 충돌이 발생하면 다음 난수를 주소로 사용한다.
  - Synonym : 해싱에서 충돌로 인해 동일한  홈 주소를 갖는 레코드들의 집합
  - Slot : 1 개의 레코드를 저장할 수 있는 공간
  - Bucket : 하나의 주소를 갖는 파일의 한 구역, 여러 개의 슬롯으로 구성된다.
    - 버킷의 크기는 같은 주소에 포함될 수 있는 레코드의 수를 의미한다.
  - 선형 개방 주소법 : 해싱에서 충돌 (오버플로우가 발생하면)이 일어난 자리에서 그 다음 버킷들을 차례로 하나 씩 검색하여 최초로 나오는 빈 버킷에 해당 데이터를 저장하는 방법


- 직접 접근 방식 (DAM :Directed Access Method) : 파일을 구성할 때 해싱이 사용되며, 접근 속도는 빠르지만 기억 공간이 많이 요구된다.
- 개체-관계 모델 (E-R Diagram)
  - 개체 타입 - 사각형, 속성 - 원형, 관계 타입 - 마름모, 연결 - 선


- Transaction
  - 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation, 독립성), 영속성(Durablity, 지속성)
  - Locking (병행 제어)
    - 로킹 단위 : 한꺼번에 로킹할 수 있는 단위 (데이터베이스, 파일, 레코드 등이 로킹 단위로 사용된다.)
    - 로킹의 단위가 작아지면 로크 수가 많아져 관리가 복잡하다. 때문에 오버헤드가 증가하지만 병행성 수준은 높아지고 데이터베이스 공유도가 증가한다.
    - 2 단계 로킹 규약 : 모든 트랜잭션들이 lock과 unlock 연산을 2 단계로 구분하여 실행된다.
      - 기본 로킹 기법의 문제점을 해결
      - 직렬 가능성을 보장하지만 교착 상태를 예방할 수 없다.
      - 트랜잭션은 lock만 수행할 수 있고 unlock은 수행할 수 없는 확장 단계가 있다.
      - 트랜잭션이 unlock과 lock을 동시에 수행할 수 있는 단계를 병렬 전환 단계라고 한다.
      - 한 트랜잭션이 unlock 후 다른 데이터를 lock할 수 있다.


- Schema : 데이터베이스의 구조와 제약조건에 대해 기술한 메타데이터의 모음
  - Data Entity, 속성, 관계와 데이터 조작에 대한 제약조건을 정의한다.
  - 외부 스키마 (External Schema)
  - 개념 스키마 (Conceptual Schema)
  - 내부 스키마 (Internal Schema) : 물리적 저장 장치의 입장에서 보는 데이터베이스 구조
    - 물리적인 구조를 정의하고 시스템 프로그래머나 시스템 설계자가 보는 관점의 스키마


- 데이터베이스 설계 단계
  * 개념적 설계 단계 (Transaction Modeling)
    * 개념 스키마 설계
    * 산출물로 ER-D (ER Diagram)이 만들어 진다.
  * 논리적 설계 단계 (목표 DBMS에 맞는 논리 스키마를 설계)
    * 트랜잭션의 인터페이스를 설계한다.
  * 물리적 설계 단계 (목표 DBMS에 맞는 물리적 구조를 설계)
    * 어떤 인덱스를 만들 것인가?
    * 성능 향상을 위한 개념 스키마의 변경 여부 검토
    * 빈번한 질의와 트랜잭션들의 수행 속도를 높이기 위한 고려
    * 다양한 데이터베이스 응용에 대해 처리 성능을 얻기 위해 데이터베이스 파일의 저장 구조 및 액세스 경로 결정
    * 저장 레코드의 양식 설계, 레코드 집중(Record Clustering)의 분석 및 설계, 접근 경로 설계 등
    * 기본적 데이터 단위 : 저장 레코드(Stored Record)
    * 물리적 데이터베이스 구조는 여러 가지 타입의 저장 레코드의 집합이라는 점에서 단순한 파일과는 다르다.
    * 데이터베이스 시스템 성능에 중대한 영향을 미친다.
  * 구현 단계 (DDL로 스키마 작성)





-  View에 대한 조작은 기본 테이블 조작과 비슷하지만 삽입, 삭제, 갱신 연산에는 제약이 따른다.





- 개체 무결성 : 한 릴레이션의 기본키를 구성하는 어떠한 속성값도 NULL 값이나 중복 값을 가질 수 없다.
- 도메인 무결성 : 주어진 속성의 값이  그 속성이 정의된 도메인에 속한 값이어야 한다.
- 무결성을 규정할 때는 이름, 검사 시기, 제약 조건 등을 명시





- DDL (Data Definition Language) : CREATE, ALTER, DROP, RENAME, TRUNCATE
- DML (Data Manipulation Language) : SELECT, INSERT, UPDATE, DELETE
- DCL (Data Control Language) : GRANT, REVOKE
- TCL (Transaction Control Language) : COMMIT, ROLLBACK, SAVEPOINT
- Stack : Last-In First-Out

  - 응용 분야 :  함수의 호출 순서 제어, 인터럽트의 처리, 후위 표기법(Postfix)으로 표현된 수식의 계산, 부프로그램 호출 시 복귀 주소를 저장, 0-주소 지정 방식 명령어의 자료 저장소
- Queue : First-In First-Out

  - 응용 분야 : 운영체제의 작업 스케줄링



- 관계 해석 (Relational Calculus) : 원하는 정보가 무엇이라는 것만 정의하는 비절차적인 특성을 갖는다.
  - Tuple 관계 해석과 Domain 관계 해석이 있다.
  - 원하는 Relation을 정의하는 방법을 제공한다.
  - E.F.Codd(코드)가 수학의 Predicate Calculus에 기반을 두고 제안했다.
  - 계산 수식을 사용해 어떤 데이터를 가져올지 명시한다.
- 관계 대수 (Relational Algebra) : 원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 절차적인 특성을 갖는다.



- 데이터베이스 보안 : 불법적인 데이터 접근으로부터 데이터베이스를 보호한다.
  - 보안을 위한 데이터 단위는 테이블 전체로부터 특정 테이블의 특정한 행과 열의 위치에 있는 특정한 데이터 값에 이르기까지 다양하다.
  - 각 사용자들은 일반적으로 서로 다른 객체에 대하여 다른 접근 권리 또는 권한을 갖게된다.
  - 보안을 위한 사용자들의 권한 부여는 DBA(DataBase Administrator)의 정책 결정에 따라 제공된다.
- 선택 정렬 : 단계적으로 가장 작은 값 하나를 선택하여 각각 인덱스의 위치에 있던 값과 선택된 값의 위치를 서로 바꿔주는 방식의 정렬 알고리즘
- 삽입 정렬 : 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여 자신의 위치를 찾아 삽입함으로써 정렬하는 알고리즘
- Data Warehouse : 많은 양의 데이터 저장소(Repository)
  - OLAP (On-Line Analytical Processing, 온라인 분석 처리) : 데이터 웨어하우스에 입력된 정보를 처리하는 방법

    - 데이터 웨어하우스의 데이터를 이용하여 업무에서 요구하는 유형대로 데이터를 분석하고 보고서를 생성하는 도구의 역할을 한다.
    - 종류 : ROLAP, MOLAP, HOLAP
    - 연산 : Roll-up, Drill-down, Pivoting, Slicing & Dicing
- 데이터 모델

  - 계층형
  - 망(네트워크, 그래프)형 (CODASYL DBTG 모델) : 논리적 구조를 그래프로 표현, 관계를 Owner-Member 관계라고도 한다.

    - DBTG, EDBS, TOTAL
  - 관계형
  - 스키마형


# 2. Electornic Calculator

- 디지털 IC의 특성
  - 전달 지연 시간이 가장 짧은 것부터 나열 : ECL - TTL - CMOS - MOS
  - (E (CL) T (TL)가 C (MOS) M (OS)송을 부른다)

- 등각 속도 (CAV : Constant Angular Velocity) 방식
  - 디스크에서 등각 속도 방식은 트랙의 위치에 따라 안 쪽과 바깥 쪽의 트랙의 저장 밀도가 달라진다.
  - 디스크 저장 공간이 비효율적으로 사용된다.
  - 회전 구동 장치가 간단하다.
  - 디스크 평판이 일정한 속도로 회전한다.

- 부동 소수점 표현

  - 부동 소수점 데이터
    - 바이트 머신 : 부호(Sign), 지수(Exponent), 가수(Mantissa)
  - 초당 부동 소수점 연산수 (FLOPS : Floating point Operations Per Second) -> 연산수 / 수행 시간
  - MFLOPS = FLOPS * 10^6 -> 연산 수 / (수행 시간 * 10^6)
  - GFLOPS = MFLOPS * 10^3
  - TFLOPS = GFLOPS * 10^3

- RS 플립플롭 : 기본 플립플롭, S와 R 선의 입력을 조절하여 임의의 비트 값을 그대로 유지시키거나 무조건 0 or 1 값을 기억시키기 위해 사용한다.

- JK 플립플롭 : RS 플립플롭에서 R = S = 1일 때의 미동작하는 결점을 보완 (모든 플립플롭의 기능을 포함한다.)

- D 플립플롭 : RS 플립플롭의 R 선에 인버터를 추가하여 S 선과 하나로 묶어서 입력선을 하나만 구성한 플립플롭, 입력하는 값을 그대로 저장하는 기능을 수행한다.

- T 플립플롭 : T = 1이면 현재 상태를 토글시킨다. 현재 상태와 보수 상태 두 가지 상태로만 전환된다.

  - JK-Flipflop의 두 입력선 J, K를 묶으면 하나의 입력선을 가진 T-Flipflop을 구성할 수 있다.

- M/S 플립플롭 : 출력 측의 일부가 입력 측에 피드백(feedback, 궤환)되어 유발되는 레이스 현상을 없애기 위해 고안되었다.

- CPU

  - 구성 요소

    - 가산기

      - 반가산기 : AND, OR, NOT 게이트로 구성

      - 전가산기 : 두 개의 반가산기, 하나의 OR 게이트로 구성

          cf) 병렬 가산기

            - 음수 표현을 위해 2의 보수를 사용할 경우, 병렬 가산기는 아래 연산을 수행한다.

          $$
          F = (A - 1 + 1) = A
          $$

    - Decoder : 주로 AND 게이트로 구성

    - Register : Flip-Flop이나 Latch들을 병렬로 연결하여 구성

      - 레지스터의 크기는 워드를 구성하는 비트 개수 만큼의 플립플롭으로 구성된다.

- 직접 메모리 액세스 (DMA : Direct Memory Access) : CPU의 도움 없이 사이클 스틸을 발생시켜 메모리와 입출력 장치 사이에서 데이터를 전송한다.
  - CPU와 DMA 제어기는 메모리와 버스를 공유한다.
  - CPU를 거치지 않기 때문에 CPU의 부하가 증가되지 않고, CPU의 상태 보존이 필요 없다.
  - Interface 회로, 주소 Register, Word Count Register, 제어 Register, 자료/주소 Buffer Register 등이 있다
  - 인터럽트와 달리 주기억 장치 사이클의 특정한 사이클만 정지시킨다.

- 가상 기억 장치 (Virtual Memory) : 실질적인 기억 공간보다 큰 논리적 공간을 주소화 할 수 있다.
  - Binding Time을 늦춰 프로그램의 Relocation을 용이하게 한다.
  - 실제 기억 용량보다 큰 가상 공간을 사용자가 쓸 수 있다.
  - 오버레이(Overlay) 문제가 자동적으로 해결된다.
  - 운영체제의 설계가 복잡해 가상 기억 장치를 채택하지 않는 시스템에서 실행 속도가 느리다.

- 연관 기억 장치 (Associative Memory) : 기억 장치에서 자료를 찾을 때 주소에 의해 접근하지 않고, 기억된 정보의 일부분을 이용하여 원하는 정보가 기억된 위치를 알아내어 그 위치에서 나머지 정보에 접근하는 장치.
  - 연관 기억 장치는 Cache Memory나 Virtual Memory에서 사용하는 Mapping Table 구성에 사용된다.

- Cache Memory : CPU와 주기억 장치 사이에 위치하여 CPU가 주기억 장치보다 더 빠르기 때문에 컴퓨터의 처리 속도를 빠르게 하기 위한 기억 장치

  - 캐시 메모리의 쓰기 정책
    - write-through : 쓰기 동작이 캐시와 주기억 장치에서 동시에 발생하기 때문에 쓰기 동작에 걸리는 시간이 길게 소요된다.
    - write-back : 새로운 데이터가 캐시에서만 갱신된다.

- 병렬 처리 기법을 사용하는 것들 : 배열 처리기 (Array Processor), Vector Processor, Pipeline Processor

- 기억 장치 용량 = 2^워드의 수 *  워드의 길이

- 워드의 수 = MAR, AR (Address Register, 주소 선의 수), PC (Program Counter)

- 워드의 길이 = MBR, DR (Data Register, 출력 데이터 선의 수)

- 누산기 (Accumulator) : CPU에서 연산한 결과를 일시적으로 저장해 두는 레지스터, 연산 장치에 있는 레지스터 중 하나

- XOR (Exclusive OR) Gate : T = A'B + AB' (입력이 한 개라도 다르면 1)

- 마이크로 명령어 (Micro Instruction)

  - 연산 필드가 2 개인 경우 2 개의 마이크로 연산이 동시에 수행된다.
  - 주소 필드는 분기가 발생할 경우 목적지 마이크로 명령어 주소로 사용된다.
  - 분기 필드는 분기의 종류와 다음에 실행할 마이크로 명령어의 주소를 결정하는 방법을 명시한다.
  - 0-주소 명령어(instuction) : 기억 장치에 접근할 Operand부가 없이 연산자(OP Code)부 만으로 구성된다.
    - 0-주소 명령어의 모든 연산은 Stack에 있는 Data를 이용하여 수행된다.
  - 1-주소 명령어 : 누산기를 이용하여 명령어를 처리한다.
    - MUL A : AC <- AC * M[A]
  - 3-주소 명령어 : OP-Code부와 3 개의 Operand 부로 구성된다.
    - 전체 프로그램의 길이는 짧아지지만, 명령어 한 개의 길이는 길어진다.

- 마이크로 프로그램 제어기가 다음에 수행할 마이크로 인스트럭션 주소를 결정하는데 사용하는 정보

  - 인스트럭션 레지스터 (IR : Instruction Register), CPU의 상태 레지스터, 마이크로 인스트럭션에 저장된 주소

- PSW (Program Status Word) : 컴퓨터 시스템 내부에서 프로그램 순간 순간의 상태를 기록한다.





- Flag Register : 명령어를 수행할 때마다 결과가 0인지, 부호(음수인지 양수인지), Carry 및 Overflow의 발생 여부 등을 각각 1비트로 나타내고 분기를 결정하는 중요한 역할을 하며 PSWR(Program Status Word Register) 이라고 부르기도 한다.

  - 시스템 내부의 순간순간의 상태를 기록하고 있는 PSW(Program Status Word)를 저장하는 Register

- N 가지의 정보를 2 진수 코드로 부호화하는데 필요한 비트 수를 계산하는 방법


  - $$
    log_2N
    $$

    ​

- 상대 (Relative) 주소 지정 방식  : 명령어의 주소 부분에 PC가 더해져서 유효 주소를 결정하는 방식

- 묵시적 (Implied) 주소 지정 방식 : Operand가 명령어에 묵시적으로 지정되어 있다.

- 즉시 (Immediate) 주소 지정 방식 : 명령어의 Operand부에 실제 데이터가 기록되어 있다.

- 직접 (Direct) 주소 지정 방식 : 명령어의 Operand부에 유효 주소가 기록되어 있다.

- 간접 (Indirect) 주소 지정 방식 : 명령어의 Operand부에 유효 주소를 찾을 수 있는 주소가 기록되어 있다.

- Daisy-Chain : 인터럽트를 발생하는 모든 장치들을 인터럽트의 우선 순위에 따라 직렬로 연결함으로써 이루어지는 우선 순위 인터럽트 처리 방법

  - 하드웨어 우선 순위 판별 방법
  - 장치 번호 버스를 이용한다.
  - 벡터에 의한 인터럽트 처리 방법
  - 빠른 응답 속도

- Fetch (인출) : 주소에 의하여 다음에 실행할 명령어를 기억 장치로부터 CPU로 가져와 해독한다.

- Indirect (간접) : Fetch Cycle에서 해석된 명령의 Operand부가 간접 주소일 경우, 유효 주소를 구한다.

- Execute (실행) : 명령 실행

- Interrupt : 인터럽트 발생 시 복귀 주소를 저장시키고, 제어 순서를 인터럽트 처리 프로그램의 첫 번째 명령으로 옮긴다.

  - 인터럽트 우선 순위 판별 방법

    - 소프트웨어적인 방법 : 폴링
    - 하드웨어적인 방법 : 데이지 체인
  - Interrupt 수행 순서
    1. 인터럽트 요청 신호 발생
    2. 현재 수행 중인 명령을 완료하고, 상태를 기억 : PSW(Program Status Word)에 현재의 상태를 보관
    3. 인터럽트 요청 장치 탐색 : CPU는 인터럽트를 요구한 장치를 확인하기 위해 입출력 장치를 폴링한다.
    4. 인터럽트 취급 루틴 수행 : 인터럽트를 요구한 장치를 위해 인터럽트 서비스 프로그램을 실행한다.
       - 인터럽트 서비스 프로그램은 실행하는 중이더라도 우선 순위가 더 높은 다른 인터럽트를 처리할 수 있다.
    5. 보존한 프로그램 상태 복귀
  - 인터럽트 발생 원인
    - 정전, Operator의 의도적인 조작, 실행되는 부프로그램에 대한 호출(서브 루틴 호출)
    - 기억 공간 내 허용되지 않은 공간에 접근 시도
  - 벡터 인터럽트 (Vectored Interrupt) : 하드웨어 신호에 의해 인터럽트가 판별되고, 인터럽트 번호만큼 떨어진 거리에 해당 인터럽트 취급 루틴을 호출할 수 있는 주소 값을 저장하는 방식
    - 하드웨어 신호에 의해 특정 번지의 서브 루틴을 수행한다.
  - 인터럽트 서비스 루틴을 실행할 때 인터럽트 플래그(IF : Interrupt Flag)를 0으로 하면 인터럽트 발생을 방지할 수 있다.
  - 인터럽트가 발생 했을 때 CPU의 상태를 보존해야 인터럽트 요청 처리 후 본래의 작업을 다시 수행 가능하다.
  - 인터럽트가 발생하게 되면 인터럽트 벡터에 의해 인터럽트 서비스 루틴이 수행되는 동안 CPU는 다른 작업을 수행한다.

- 자기 코어 기억 장치 : 중심을 통과하는 전선에 흐르는 전류의 방향에 따라 1 또는 0의 값을 갖는다.

  - 1 word = 16 비트라면 16 장의 코어 플레인(Core Plane)이 필요하다.

- 연산자(OP Code)부의 비트 수가 n bit이면 명령어 개수는 최대 2^n

- 시프트 연산

  - 오른쪽으로 시프트 시 밀려나는 비트가 1이면 절단 현상이 발생한다.
  - 시프트 시 새로 들어오는 비트는 0이다.
  - 오른쪽으로 시프트 1번은 2배, 왼쪽으로 시프트 한 번은 2로 나눈 것과 같다.



- Decoder : n개의 입력선을 통하여 들어온 2진 신호를 최대 2^n개의 출력선 중 하나를 선택하여 출력하는 장치



- 단항 (Unary) 연산자 : NOT(Complement), Shift, Rotate, Move etc..
- 이항 (Binary) 연산자 : 사칙 연산(ADD, SUB, MUL, DIV), AND, OR, XOR etc..
- ​
  1. MAR <- MBR(ADDR) // MBR의 주소를 MAR로 전달
  2. MBR <- M(MAR) // 메모리의 MAR을 MBR로 전달
  3. EAC <- AC + MBR // 누산기와 MBR의 값을 더한 결과값을 EAC에 저장


- ROM (Read Only Memory) : 읽기 전용 기억 장치 (기억된 내용을 읽기만 할 수 있다.)
  - 칩 선택 신호, 읽기 신호, 주소선, 데이터 버스로 구성




- 소형 계산기에서 BCD 코드 대신 excess-3 코드를 많이 사용하는 가장 큰 이유는 자기 보수가 가능한 코드이기 때문이다.

- Loader의 기능

  - 할당(Allocation) : 각 세그먼트가 주기억 장치 내의 어느 곳에 위치할 것인가를 결정
  - 연결(Linking) : 각 세그먼트들을 연결
  - 재배치(Relocation) : 디스크 등의 보조기억 장치에 저장된 프로그램이 사용하는 각 주소들을 할당된 기억 장소의 실제 주소로 배치
  - 적재(Loading) : 각 세그먼트를 주기억 장치 내의 할당된 장소에 넣는다.
  - Relative Loader (상대 로더) = Direct Linking Loader (직접 연결 로더), Relocation Loader (재배치 로더)

    - 로더의 기능 4 가지 모두 수행

- Micro Operation : 레지스터에 저장된 데이터에 의해 이루어지는 동작


    - 명령어 실행 과정

        - 명령어 인출 (IF : Instruction Fetch)
      - 명령어 해독 (ID : Instruction Decode)
      - 오퍼랜드 인출 (OF : Operand Fetch)
      - 실행 (EX : Execute)

    - 명령어 실행 시간 구하는 법

        - 파이프라인 클록 주파수로 클록 주기를 구한다. (역수, 1Ghz -> 1ns)

      - 첫 번째 명령어를 실행하는 동안의 시간을 구한다. (모든 과정 수행 시간의 합)

      - 다음 명령어부터는 다른 과정을 수행하는 동안 병렬 처리되므로 마지막 과정의 수행시간들만 더해주면 된다.

      - T = 전체 실행 시간, K = 파이프 라인 단계(과정)의 수, N = 명령어 개수, PCT = 파이프라인 클록 주기(클록 시간)

      - $$
        T = (K + (N - 1)) * PCT
        $$

        - 한 개의 Clock Pulse 동안 실행되는 기본 동작 (기준 : Clock)

        - 한 개의 Instruction = 다수의 Micro Operation

        - Micro Operation은 명령을 수행하기 위해 CPU 내의 Register와 Flag의 상태 변환을 일으킨다. 이는 제어 신호 (Control Signal)에 의해 순서적으로 일어난다.

        - Micro Operation Cycle Time 부여 방식

          - 동기 고정식 (Syncronous Fixed) : 모든 Micro Operation의 동작 시간이 같다고 가정하여 CPU Clock Cycle과 Micro Operation Cycle Time을 같게 정의한다. 모든 Micro Operation 중 동작 시간이 가장 긴 Micro Operation의 동작 시간을 Micro Operation Cycle Time으로 정의한다.

            - 모든 Micro Operation 동작 시간이 같을 때 유리하다.
            - 제어기의 구현이 단순하나 CPU의 시간 낭비가 심하다.
          - 동기 가변식 (Syncronous Variable) : 수행 시간이 비슷한 Micro Operation끼리 그룹지어 그룹 별로 Micro Operation Cycle Time을 정의한다. 수행 시간이 현저히 차이날 때 사용한다.

            - 동기 고정식에 비해 CPU의 시간 낭비를 줄일 수 있지만 제어기의 구현이 복잡하다.
            - 각 그룹 간 서로 다른 Cycle Time 동기를 맞추기 위해 그룹 간 Cycle Time을 정수 배가 되도록 설정한다.
          - 비동기식(Asyncronous)  : 모든 Micro Operation에 대해 서로 다른 Micro Operation Cycle Time을 부여한다.

            - CPU의 시간 낭비는 없지만 제어기가 매우 복잡해지므로 실제로는 거의 사용하지 않는다.

        - 수직 마이크로 방식의 명령어는 연산 필드(F1, F2, ..., FN)의 수만큼 제어 신호가 동시에 생성될 수 있다.

        - AND 마이크로 동작과 가장 유사한 것은 mask 동작

  - 간접 사이클 (Indirected Cycle) : 인출(Fetch) 단계에서 해석된 명령의 주소부가 간접 주소인 경우에 수행된다. 
    - MAR <- MBR[address], MBR <- memory[MAR]
    - MAR <- IR(addr), MBR <- memory or register), IR <- MBR(addr)

  - 인출 사이클 (Fetch Cycle) : MAR <- PC

  - 실행 사이클 (Execute Cycle)

  - 인터럽트 사이클 (Interrupt Cycle) : MBR[address] <- PC, PC <- 0

- I/O Operation
  - Programmed I/O, Interrupt I/O, DMA에 의한 I/O, Channel에 의한 I/O, Strobe 제어 방식, Handshaking 방식

- RAM


  - SRAM (정적 기억 장치) : 입력과 클록에 따라 상태가 변하는 논리 회로

    - 플립플롭을 사용해 데이터를 저장하기 때문에 재충전이 필요없다. (방전되지 않는다.)
    - 캐시 메모리로 주로 사용된다.
  - DRAM (동적 기억 장치) : 캐패시터(콘덴서)에 전하를 저장하는 방식으로 데이터를 저장한다.

    - 캐패시터(콘덴서) 때문에 방전 현상이 일어나기 때문에 재충전이 필요하다.
    - 상대적으로 소비 전력이 적으며 대용량 메모리 제조에 적합하다.
- SDRAM : 여러 개의 내부 뱅크들에서 동시 액세스가 진행된다.
  - 버스 클럭에 동기화되어 정보가 전송된다.
  - 여러 개의 데이터들을 연속으로 전송하는 버스트 모드를 지원한다.
- 데이터의 기억 형태에 따른 기억 장치

  - 정적 기억 장치 - SRAM, 동적 기억 장치 - DRAM, 비파괴적 읽기(Non-Destructive Read Out) - ROM
  - 파괴적 읽기(Destructive Read Out) : 해당 장치에서 데이터를 읽으면 내용이 손상된다.

    - 자기 드럼, 자기 코어
- 사상 함수 (Mapping Function) :  명령어가 수행될 때 주기억 장치에 접근하기 위해 명령어에서 사용한 주소를 주기억 장치에 직접 적용될 수 있는 주소로 변환에 사용되는 함수
  - 주기억 장치 내에 한 개의 블록에 캐시 라인을 배정하는 규칙
  - 직접 사상 (Direct Mapping) : 기억시킬 캐시 블록 결정 함수는 주기억 장치의 블록 번호를 캐시 전체 블록 수로 나눈 나머지로 정한다.
  - 전체 연합 사상 (Fully Associative Mapping) : 주기억 장치 내 임의의 블록 하나를 캐시 전체 블록 중 아무 곳이나 하나 정해서 기억시키는 방법
  - 세트 연합 사상 (Set Associative Mapping) : 직접 사상 +  연합 사상
- 파이프 라인 구조를 사용하면 Clock Cycle = 가장 큰 시간 지연 + 중간 레지스터 시간 지연
- 비 파이프 라인 구조에서는 Clock Cycle = 모든 세그먼트의 시간지연의 합
- 언팩 (UNPACK) 10진법 : 1 바이트를 Zone, Digit 두 부분으로 구성
  - Zone 부분에는 항상 F(1111)가 들어가고 Digit 부분에는 10진수 값이 8421 BCD 코드 형식으로 들어간다.
  - 가장 오른쪽 Byte의 Zone 부분에 부호를 표시한다. 양수는 C(1100), 음수는 D(1101) 부호가 없을 때는 F(1111)
- 팩 (PACK) 10진법 : 1 바이트에 2 개의 Digit를 각각 8421 BCD 코드로 표시한다.
  - 언팩 10진법은 연산이 불가능하므로 팩 10진법으로 변환시켜 연산을 하고 다시 언팩 10진법으로 변환한다.
  - 가장 오른쪽 Byte의 하위 4 비트에 부호를 표시한다.
    - ASCII 코드 : 양수는 A(1010), 음수는 B(1011)
    - EBCDIC 코드 : 양수는 C(1100), 음수는 D(1101)
- 메모리 인터리빙 : 주기억 장치에 접근하는 속도를 빠르게 하기 위해 인접한 메모리의 위치를 서로 다른 Bank에 둠으로써 동시에 여러 곳을 접근할 수 있게 한다. 서로 다른 메모리 뱅크에 번갈아가며 연속적인 주소를 부여함으로써 하나의 메모리 주소에 접근하여 처리하는 동안에도 다음 메모리 주소에 접근할 수 있게 한다. 이로써 대역폭을 늘려주는 효과를 갖는다.
- 메모리 버스트 : 주소에 접근할 때 미리 길이를 4개 또는 8개 정도로 지정해 놓고 연속된 데이터를 읽어온다.
- 메모리에 접근 빈도가 많아질수록 속도가 느려지며, 속도가 느려질수록 사용 빈도가 낮아진다.
  - Memory-Memory Instruction : 메모리에 2번 접근
  - Register-Register Instruction : 메모리에 0번 접근
  - Register-Memory Instruction : 메모리에 1번 접근
  - Stack Instruction : 메모리에 0번 접근
- 그레이 코드는 XOR 연산을 사용하여 만든 코드
- Stack : Last-In First-Out
  - 응용 분야 :  함수의 호출 순서 제어, 인터럽트의 처리, 후위 표기법(Postfix)으로 표현된 수식의 계산, 부프로그램 호출 시 복귀 주소를 저장, 0-주소 지정 방식 명령어의 자료 저장소
- 8진수에서 7의 보수를 구하려면 777 - 8진수, 여기에 1을 더하면 8의 보수
- 페이지 부재 (Page Fault) : CPU가 접근한 가상 페이지가 주기억 장치에 없는 경우
  - 가상 메모리를 사용한 컴퓨터에서 Page Fault가 발생하면 요구된 Page가 주기억 장치에 옮겨질 때까지 프로그램의 수행을 중단한다.
- 가변 우선 순위 방식
  - 동등 우선 순위 (Equal Priority) : 모든 버스 마스터들이 동등한 우선 순위를 갖는다. FIFO 방식 사용
  - 임의 우선 순위 (Random Priority) : 버스 사용 승인을 받아서 버스 중재의 동작이 끝날 때마다 우선 순위를 임의로 결정하는 방식
  - 회전 우선 순위 (Rotate Priority) : 버스 사용 승인을 받은 버스 마스터는 최하위 우선 순위를 갖고 바로 다음 위치한 마스터가 최상위 우선 순위를 갖도록 하는 방식
    - 중재 동작이 끝날 때마다 모든 마스터들의 우선 순위가 하나 씩 낮아지고 가장 우선 순위가 낮았던 마스터가 최상위 우선 순위를 갖는다.
  - 최소-최근 사용 (Least-Recently Used) : 최근 가장 오랫동안 사용되지 않은 버스 마스터에게 최상위 우선 순위를 부여하는 방식
- 해밍 코드 (Hamming Code) : 전송 비트 중 2^n번 째 비트는 오류 검출을 위한 패리티 비트(해밍 비트)이다.


  - 패리티 비트를 포함한 1의 개수가 짝수가 되도록 패리티 비트를 설정해야 한다.

    - (1, 3, 5, 7), (2, 3, 6, 7), (4, 5, 6, 7)


# 3. Operating System

- 시스템 소프트웨어의 구성
  - 처리 프로그램 : Language Translate Program, Service Program, Problem Program
- 운영체제의 기능에 따른 분류
  - 제어 프로그램 : 데이터 관리 프로그램 (Data Management Program), 감시 프로그램 (Supervisor Program), 작업 제어 프로그램 (Job Control Program)
  - 처리 프로그램 : 언어 번역 프로그램, 서비스 프로그램, 문제 프로그램
- 운영체제의 성능 평가 요인
  - 처리 능력 (Throughput) : 일정 시간 내에 시스템이 처리하는 작업량
  - 사용 가능도 (Availability) : 사용자가 요구할 때 얼마나 신속하게 지원하는가?에 대한 척도
    - 컴퓨터 시스템 내의 한정된 각종 자원을 여러 사용자가 요구할 때, 어느 정도 신속하고 충분히 지원해 줄 수 있는지의 정도
    - 사용 가능한 하드웨어 자원의 수나 다중 프로그래밍 정도 등의 요소에 좌우된다.
    - 같은 종류의 시스템 자원의 수가 많을 때 높아질 수 있다.
  - 반환 시간 (Turn Around Time) : 시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간
  - 신뢰도 (Reliability) : 시스템이 주어진 문제를 정확하게 해결하는가?에 대한 척도
- 기억 장치의 관리 전략
  - 반입 (Fetch) : 보조기억 장치에 보관 중인 프로그램이나 데이터를 주기억 장치로 언제 가져올 것인가를 결정
- 다중 처리기(Multi-Processor) 운영체제 구성
  - 주/종(Master/Slave) 처리기 시스템
    - 주 프로세서 : 입출력 및 연산을 모두 담당, 주 프로세서만이 운영체제를 수행한다.
      - 주 프로세서에 문제 발생 시 컴퓨터 시스템 전체가 중단된다.
    - 종 프로세서 : 연산을 담당
- 교착 상태 (Deadlock)
  - 발생 조건 : 상호 배제(Mutual Exclusion), 점유와 대기(Hold and Wait), 비선점(Non-preemption) 환형 대기(Circular Wait)
  - 해결 방법
    - Avoidance(회피) : 교착 상태가 발생할 가능성을 배제하지 않고 교착 상태가 발생하면 적절히 피해가는 방법 (Banker's Algorithm : 은행가 알고리즘, 은행원 알고리즘)
    - Detection(발견)  : 시스템에 교착 상태가 발생했는지 점검하여 교착 상태에 있는 프로세스와 자원을 발견하는 것 (자원 할당 그래프 등을 사용한다.)
    - Prevention(예방) : 교착 상태가 발생되지 않도록 사전에 시스템을 제어하는 방법
      - 교착 상태 발생의 조건 4 가지 중에서 어느 하나를 제거함으로써 수행된다.
      - 일반적으로 자원의 낭비가 가장 심하다.
    - Recovery(회복) : 교착 상태를 일으킨 프로세스를 종료하거나 교착 상태의 프로세스에 할당된 자원을 선점하여 프로세스나 자원을 회복하는 것이다.
- Process  : 현재 실행 중인 프로그램
  - PCB를 가진 프로그램
  - 비동기적 행위를 일으킨다.
  - 프로세서가 할당되는 실체
  - 활동 중인 Procedure이다.
  - 상태 전이 : Dispatch, Spooling, Wake up
- Real Time Processing : 한정된 시간 내 자료를 분석하여 정해진 시간 내에 반드시 작업을 처리해야 하는 시스템
- 데커 알고리즘 (Dekker's Algorithm) : 두 프로세스 간의 상호배제에 대한 단계적 해결 방법을 기술
  - 임계 구역 (Critical Section)은 특정 프로세스가 독점할 수 없기 때문에 임계 구역에 들어가는 것이 무한정 지연될 수는 없다.
  - 교착 상태 (Deadlock)가 발생하지 않음을 보장
  - 공유 데이터에 대한 처리에 있어서 상호배제를 보장
  - 별도의 특수 명령어 없이 순수하게 소프트웨어만으로 해결된다.
- 파일 구성 방식
  - ISAM (Indexed Sequential Access Method)
    - 물리적 색인 구성 : 디스크의 물리적 특성에 따라 색인을 구한다.
      - 3 단계 색인
        - 트랙 색인 영역 (Track Index) : 각 실린더마다 하나 씩 만들어지며 각 트랙에 기록된 데이터와 레코드 키 값 중 최대 키 값과 주소 정보가 기록되는 방식
        - 실린더 색인 영역 (Cylinder Index) : 각 파일 당 하나 씩 만들어지며 각 트랙 색인의 최대 키 값들로 구성된 영역
        - 마스터 색인 영역 (Master Index) : 실린더 색인이 많은 경우 그것을 일정한 크기의 블록으로 구성하고 해당 레코드가 어느 실린더 색인 영역에 있는지 나타내는 영역
- 스래싱 (Thrashing) : 하나의 프로세스가 작업 수행 과정에서 수행하는 기억 장치 접근에서 지나치게 페이지 폴트가 발생하여 프로세스 수행에 소요되는 시간보다 페이지 이동에 시간이 더 커지는 현상, 가상 기억 장치 시스템에서 발생
- N-step SCAN Scheduling : 어떤 방향의 진행이 시작될 당시에 대기 중이던 요청들만 서비스하고, 진행 도중 도착한 요청들은 한데 모아서 다음의 반대 방향 진행 때 최적으로 서비스하는 기법
  - SCAN의 무한 대기 발생 가능성을 제거한 기법, SCAN보다 응답시간의 편차가 적다.
- 디렉토리 구조
  - 트리 디렉토리
  - 비순환 그래프 디렉토리
  - 1 단계 디렉토리
  - 2 단계 디렉토리 : 마스터 파일 디렉토리는 각 사용자의 이름이나 계정 번호, 그리고 사용자 파일 디렉토리를 가리키는 포인터를 갖고 있으며 사용자 파일 디렉토리를 관리한다.
- Working Set : 프로세스가 자주 참조하는 페이지들의 집합





- UNIX : 대화식 운영체제, 다중 사용자 시스템(Multi-user System), 대부분 C언어로 작성되어 이식성과 확장성이 높다.

  - getppid() : 부모의 프로세스 id를 얻는다.
  - getpid() : 자신의 프로세스 id를 얻는다.
  - fork() : 프로세스 생성, 복제
  - exec() : 새로운 프로세스 수행
  - exit() : 프로세스 수행 종료
  - make() : 컴파일 수행
  - Kernel : 프로세스를 관리한다.
  - Shell : 명령어를 해석한다, 단말 장치로부터 받은 명령을 커널로 보내거나 해당 프로그램을 작동시킨다, 사용자와 Kernel 사이에서 중계자 역할을 한다.
  - & : 실행 명령의 백그라운드(Background) 처리를 위해 명령어의 끝에 붙인다.



- 분산 처리 시스템 (Distributed Processing System) : 자원 공유, 연산 속도 향상, 신뢰도 향상 등의 장점이 있지만 보안 문제가 발생할 수 있으며 집중형(Centralized) System에 비해 개발 비용이 증가한다.

  - 프로세스 모델에 따른 분류

    - 클라이언트-서버 모델
    - 프로세서 폴 모델
    - 혼합 모델
  - 위상에 따른 분류

    - 다중 접근 버스 모델



- Thread : 하나의 프로세스 내에서 병행성을 증대시키기 위한 메커니즘
  - 프로세스의 일부 특성을 갖고 있기 때문에 경량 프로세스(Light Weight Process)라고도 불린다.
  - 단일 프로세스를 다수의 스레드로 생성하여 병행성을 증진시킨다.
  - 스레드 기반 시스템에서는 독립적인 스케줄링의 최소 단위로서 프로세스의 역할을 맡는다.
  - 실행 환경을 공유시켜 기억 장소의 낭비가 줄어든다.
  - 프로세스들 간의 통신을 향상시킬 수 있다.




- 직접 파일 (Direct File) : 키에 일정한 함수를 적용하여 상대 레코드 주소를 얻고, 그 주소를 레코드에 저장하는 파일 구조
  - 직접 접근 기억 장치의 물리적 주소를 통해 직접 레코드에 접근한다.
  - 직접 접근 기억 장치의 물리적 구조에 대한 지식이 필요하다.
  - 자기 디스크를 주로 이용한다.





- Spooling (Simultaneous Peripheral Operation On-Line) : 어떤 작업의 입출력과 다른 작업의 계산을 병행처리하는 기법
  - 디스크를 버퍼로 사용
  - 다중 프로그래밍 시스템의 성능 향상





- 데이터 관리 프로그램 (Data Management Program) : 주기억장치와 보조기억장치 사이의 자료 전송, 파일의 조작 및 처리, 입/출력 자료와 프로그램간의 논리적 연결 등, 시스 템에서 취급하는 파일과 데이터를 표준적인 방법으로 처리할 수 있도록 관리한다.





- Flynn이 제안한 4가지 병렬처리 방식
  - MISD (Multiple Instruction stream Single Data stream) : 다수의 프로세서에 의해 서로 다른 명령이 하나의 자료를 처리한다. 실질적으론 사용되지 않는다.




- 회피 기법 (Avoidance) : 교착 상태의 발생 가능성을 인정하고 교착 상태가 발생하려 할 때 피해가는 방법
  - 은행원 알고리즘 (Banker's Algorithm)



- LRU (Least Recently Used) : 현 시점에서 가장 오랫동안 참조되지 않았던 페이지를 먼저 교체하는 기법
- NUR (Not Used Recently) : 각 페이지마다 두 개의 하드웨어 비트(참조 비트, 변형 비트)를 두고서 가장 최근에 사용하지 않은 페이지를 먼저 교체하는 기법



- 운영체제의 자원 관리 과정
  1. 시스템 내 모든 자원들의 상태를 파악
  2. 어떤 프로세스에게 언제, 어떤 자원을 할당할 것인가를 결정하는 분배 정책 수립
  3. 자원을 배당하고 운영함으로써 수립된 정책을 수행
  4. 프로세스에 배당된 자원을 회수


-  가상 기억 장치 : 보조기억 장치의 일부 용량을 주기억 장치처럼 가상하여 사용할 수 있는 기법
  - 주기억 장치의 물리적 공간보다 큰 프로그램을 실행 가능하다.
  - 운용 기법
    - 페이징 : 가상 메모리를 같은 크기의 블록으로 편성하여 운용하는 기법
      - 페이지 : 일정 크기의 블록
      - 주소 변환을 위한 페이지 맵 테이블이 필요하다.
      - 내부 단편화가 발생할 수 있다.
      - 페이지 크기가 작아질수록 기억 장소 이용 효율이 증가하고, 내부 단편화가 감소하며, 입출력 시간이 늘어난다.
    - 세그먼테이션 : 메모리 크기를 실제 운영되는 작업의 크기에 따라 편성하여 운용하는 기법
      - 하나의 작업을 크기가 각각 다른 여러 논리적인 단위로 나누어 사용한다.
      - 세그먼트 : 변형되는 메모리의 논리적 단위
      - 외부 단편화가 발생할 수 있다.



- 선점(Preemptive) 스케줄링 : 하나의 프로세스가 CPU를 할당받아 실행하고 있을 때, 우선 순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법

  - 우선 순위가 높은 프로세스를 빠르게 처리할 수 있다.
  - 주로 빠른 응답 시간을 요구하는 대화식 시분할 시스템에 이용된다.
  - 선점으로 인한 많은 오버헤드를 초래한다.
  - 선점을 위한 시간 배당으로 인해 인터럽트용 타이머 클럭이 필요하다.
  - 라운드 로빈 (RR : Round Robin) : 시간 할당량만큼만 모든 프로세스들을 완료될 때까지 반복적으로 수행하는 방식
    - 반환 시간 = 프로세스가 끝난 시간 - 도착 시간
  - SRT, 다단계 큐, 다단계 피드백 큐 등
- 비선점(Non-preemptive) 스케줄링 : 선점과 달리 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗을 수 없다.

  - 프로세스가 CPU를 할당받으면 해당 프로세스가 완료될 때까지 CPU를 사용한다.
  - 모든 프로세스에 대한 요구를 공정하게 처리할 수 있다.
  - 일괄 처리 방식에 적합하며, 단적인 예로 수행 시간이 짧은 중요한 작업이 중요하지 않은 수행 시간이 긴 중요하지 않은 작업을 기다리는 경우가 발생할 수 있다.
  - 응답 시간의 예측이 용이하다.
  - FCFS(First Come First Served) : 시스템에 들어와 가장 오랫동안 기다린 프로세스를 선택하여 처리
  - SJF(Shortest Job First) : 작업 시간이 짧은 프로세스를 먼저 처리
  - HRN(Highest Response Scheduling) : 준비 큐에서 기다리는 프로세스 중 응답율이 가장 큰 것을 먼저 처리한다.

    - 응답율 : (대기 시간 + 서비스 시간) / 서비스 시간 클 수록 우선 순위가 높다.
  - FIFO, 기한부, 우선순위 등
- Aging : 특정 프로세스의 우선 순위가 낮아 무한정 기다리게 되는 경우 양보하거나, 기다린 시간에 비례하여 일정 시간이 지나면 우선 순위를 한 단계씩 높여 무기한 문제를 해결하는 기법
  - SJF나 우선 순위 기법에서 발생할 수 있는 무한 연기 상태, 기아 상태를 예방할 수 있다.
- Public Key System (공용키 암호화 기법)
  - 암호화 키와 해독 키가 따로 존재한다.
  - 해독 키는 보안되어야 한다.
  - 키의 분배가 용이하다.
  - 대표적으로 RSA가 있다.
- 주기억 장치 배치 전략 기법
  - 최적 적합(Best Fit) : 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 적게 남기는 분할 영역에 배치시키는 방법
- Crossbar Switch Matrix
  - 각 기억 장치마다 다른 경로를 사용할 수 있다.
  - 시분할 및 공유 버스 방식에서 버스의 숫자를 기억 장치의 숫자만큼 증가시킨 구조이다.
  - 두 개의 서로 다른 저장 장치를 동시에 참조할 수 있다.
  - 장치의 연결이 복잡해진다.
- UNIX File System

  - 구조

    - 부트 블록 : 부팅에 필요한 내용이 저장된 공간
    - i-node 블록 : 저장된 데이터의 속성 정보들이 저장되는 공간, 데이터가 저장된 블록의 시작 주소는 데이터의 속성 정보이다.
    - 데이터 블록 : 실제 데이터가 저장되는 공간
  - 기능

    - 사용자와 보조기억 장치 사이에서 인터페이스를 제공한다.
    - 사용자가 파일을 생성, 수정, 제거할 수 있도록 한다.
    - 적절한 제어 방식을 통해 타인의 파일을 공동으로 사용 가능하게 한다.
    - 소프트웨어를 동작시켜 사용자가 작업을 편리하게 수행하도록 한다.
- Coalescing(통합) : 단편화의 해결 방법
- Garbage Collection : 메모리 공간의 절약을 위해 사용한다.
- Relocation(재배치) : 기억 장치 관리에서 Fragmentation(파편화)를 해결하기 위해 Compaction을 실행하며, 이 과정에서 주소를 새롭게 지정해주는 기법
- Swapping(교체) : 일부 프로세스를 보조기억 장치로 보냈다가 다시 주기억 장치로 불러들인다.
- 디스크 스케줄링 기법

  - FCFS (First Come First Served, FIFO) : 가장 간단한 스케줄링 대기 형태로 대기 큐에 들어온 작업 순서대로 CPU를 할당한다.

    - 도착 순서에 따라, 요청 순서대로 진행하기 때문에 공평성을 보장한다.
    - 디스크의 부하가 적을 때 유리, 부하가 커지면 응답시간 또한 늘어난다.
    - 탐색 시간의 최적화는 X
  - SSTF (Shortest Seek Time First) : 현재의 헤드 위치에서 가장 가까운 요청을 먼저 수행한다.

    - 탐색 거리가 가장 가까운 작업을 찾아 수행, 진행 방향은 양방향이 될 수 있다.
    - 무조건 가까운 작업만 먼저 수행하므로 공정성이 낮고 트랙별로 수행하는 편차가 크다.
    - 가운데 트랙이 바깥쪽 트랙보다 수행될 확률이 크다.
    - 헤드에서 멀리 떨어진 요청은 기아(Starvation) 상태가 발생할 수 있다.
    - 실시간 접근이 어려워 일괄 처리 시스템에 유용하다.
  - SCAN : 현재 진행 방향 상에서 가장 가까운 곳에 있는 작업을 수행한다. (엘리베이터식 처리)

    - 요청 큐의 동적 특성을 반영한 것으로 헤드가 디스크의 한쪽 끝에 도달하면 다시 반대쪽 끝으로 진행하며 요청된 트랙(작업)에 대해 처리한다.
    - SSTF의 낮은 공정성과 높은 편차를 개선
  - C-SCAN (Circular SCAN) : SCAN 방식의 불공평한 대기 시간을 더 균등하게 하기 위해 변형한 것.

    - 헤드는 항상 바깥 쪽 실린더에서 안 쪽 실린더로 이동하면서 가장 짧은 탐색 시간을 가진 요청을 찾아 수행한다.
  - LOOK : 헤드는 양방향으로 요청에 따르는 거리만 이동하고 현재 방향에서 더 이상 요청이 없다면 진행 방향이 바뀐다.

    - SCAN이나 C-SCAN은 실제로 구현하여 적용이 어려워 LOOK / C-LOOK의 형태로 구현한다.
  - 에션바흐 (Eschenbach) 기법 : 부하가 매우 큰 항공 예약 시스템을 위해 개발되었다.

    - 탐색 시간과 회전 지연 시간을 최적화하기 위한 최초의 기법
    - 헤드는 C-SCAN처럼 움직이며 예외적으로 모든 실린더는 그 실린더에 요청 유무에 상관없이 전체 트랙이 한 바퀴 회전하는 동안 요청을 수행한다.
  - Sector Queuing : 회전 지연 시간을 최적화하기 위한 기법

    - 탐색 시간을 필요로 하지 않는 고정 헤드 디스크 시스템이나 각 트랙마다 헤드를 갖는 드럼 등의 보조 기억 장치에서 사용된다.

# 4. Software Engineering

- 클래스 (Class) : 공통된 속성과 연산(행위)을 갖는 객체의 집합, 객체의 일반적인 타입
- 인스턴스 (Instance) : 클래스에 속한 각각의 객체
- 객체 (Object) : 데이터와 함수 기능을 갖고 있다.
- 메시지 (Message) : 객체들 간의 상호 작용을 하는데 사용되는 수단, 객체에게 어떤 행위를 하도록 지시한다.
- 소단위 명세서(Mini-Specification) : 반 페이지나 한 페이지 정도 크기로 세분화된 모듈을 작성하는데 사용
  - 서술 문장, 의사 결정 트리, 의사 결정 표, 그래프 등의 도구로 작성
  - 구조적 언어를 사용한다. (자연어 X)



- 프로젝트 비용 결정 요소
  - 프로젝트 요소 : 시스템의 크기, 제품의 복잡도, 요구되는 신뢰도
  - 생산성 요소 : 개발자의 능력, 개발 기간



- 소프트웨어 개발 단계
  - 요구 분석 : 프로젝트를 이해할 수 있는 개발의 실질적인 첫 단계
    - 현재의 상태를 파악하고 문제를 정의한 후, 문제 해결과 목표를 명확히 도출한다.
    - 소프트웨어가 가져야 될 기능들을 기술한다.
  - 설계 : 고품질의 소프트웨어를 개발하기 위해 소프트웨어의 내부 구조를 기술한다.
- 프로그램 설계도

  - 순서도 (흐름도 : Flow Chart) : 처리 단계(박스), 논리 조건(다이아몬드), 제어 흐름(화살표) 등의 기호를 사용하여 읽고 작성하기 쉬운 설계도
  - NS (Nassi-Schneiderman) Chart (= 박스 다이어그램, Chapin Chart) : 논리의 기술에 중점을 두고 도형으로 표현한 방법

    - 박스를 기본 요소로 연속, 선택 및 다중 선택, 반복 등의 제어 논리 구조 표현
    - 화살표가 없으며 입구와 출구가 하나이다.
    - 전체적인 논리 구조를 한 페이지에 표현하여 순서도보다 프로그램의 논리를 이해하기 쉽다.
    - 이해하기 쉽고 코드로의 변환이 용이하다.
  - HIPO (기능 표현 중심)



- DFD (Data Flow Diagram) : 시스템 내의 모든 데이터 흐름을 4가지 기본 기호(처리(원), 데이터 흐름, 데이터 저장소, 단말 : 화살표, 사각형, 직선(단선/이중선))로 표시하는 방법
  - 자료 흐름 그래프 또는 Bubble Chart라고도 한다.
  - 구조적 분석 기법에 이용된다.
  - 시간 흐름의 개념은 표시할 수 없다.
  - 자료 흐름은 처리(Process)를 거쳐 변환될 때마다 새로운 이름을 부여한다.
  - 어떤 처리가 출력 자료를 산출하기 위해서는 반드시 입력 자료가 발생해야 한다.
  - 자료 저장소에 입력된 화살표가 있다고 하더라도 반드시 출력 화살표가 표시될 필요는 없다. (자료 저장소로 입력되는 흐름은 자료의 입력, 수정, 삭제를 나타낸다.)
  - 상위 단계의 처리와 하위 자료 흐름도의 자료 흐름은 서로 일치되어야 한다.



- 공학(Engineering)이 가지는 의미 : 경제성, 적시성, 보편타당성
- 재공학 (Re-engineering) : 기존에 있던 소프트웨어를 파기하지 않고 새로운 기능을 추가해 예방 유지보수 측면에서 문제를 해결한다.

  - 사용자 요구 사항을 변경시키지 않고 기술적 설계를 변경하여 프로그램을 개선하는 것
  - 현재 시스템을 변경하거나 Restructuring하는 것
  - Restructuring : 재공학의 한 유형으로 사용자 요구 사항이나 기술적 설계의 변경 없이 소프트웨어를 개선하는 것
  - Redevelopment는 새로 다시 개발하는 것, 재공학과는 다르다.



- 역공학 (Reverse Engineering) : 기존 소프트웨어를 분석하여 소프트웨어 개발 과정과 데이터 처리 과정을 설명하는 분석 및 설계 정보를 재발견하거나 다시 만들어 내는 과정



- 프로토타입 모형 (Prototype Model) : 사용자의 요구사항을 충실히 반영할 수 있으며, 최종 결과물이 만들어지기 전에 최종 결과물의 일부 또는 모형을 볼 수 있다.
  - 사용자가 제시하는 불확실성 결정 요인
    - 지원이 필요한 일로부터의 요구연역
    - 사용자와 분석자의 지식과 경험의 수준
    - 커뮤니케이션 문제가 일어날 가능성
- 결합도의 종류 및 강도

  - 자료 결합도(Data Coupling), 스탬프 결합도(Stamp Coupling), 제어 결합도(Control Coupling), 외부 결합도(External Coupling), 공통 결합도(Common Coupling, 공유 결합도), 내용 결합도(Content Coupling)
  - 자 스 제 외 공 내



- Module : 하나의 프로그램을 분할하는 작은 단위

  - 응집도(Cohesion) : 모듈 안의 요소들이 서로 연관되어 있는 정도

    - 기능적 응집도(Functional Cohesion) : 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도
    - 순차적 응집도 : 한 모듈 내부의 한 기능 요소에 의한 출력 자료가 다음 기능 원소의 입력 자료로써 제공되는 형태
    - 교환적 응집도(Communication Cohesion) : 동일한 입력과 출력을 사용하는 작업들이 모인 모듈에서 볼 수 있다.
    - 절차적 응집도
    - 시간적 응집도
    - 논리적 응집도(Logical Cohesion) : 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우
    - 우연적 응집도
    - 기 순 교 절 시 논 우 (강 -> 약)
  - 좋은 모듈이 되기 위해서는 응집도는 강하게 하고, 결합도는 약하게 해야 한다. (기능적 응집도, 자료 결합도)



- CASE (Computer Aided Software Engineering) : 소프트웨어 개발 과정에서 사용되는 요구 분석, 설계, 구현, 검사 및 디버깅 과정을 컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화하는 작업
  - 소프트웨어 생명 주기(Software Life Cycle)의 전체 단계를 연결시켜 주는 통합된 도구를 제공한다.
  - 다양한 소프트웨어 개발 모형 지원
  - 그래픽 지원



- CPM (Critical Path Method) : 작업들 간의 상호 관련성, 결정 경로를 표시한다.



- 럼바우(Rumbaugh)의 객체 모델링 기법 : 객체 - 동적 - 기능 순으로 이루어 진다.

  - 객체 모델링(Object Modeling) : 정보 모델링이라고도 한다. 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 그래픽 다이어그램으로 표시한다.

    - 객체, 메소드, 속성, 식별
  - 동적 모델링(Dynamic Modeling) : 상태도를 이용하여 시간의 흐름에 따른 객체들 사이의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현한 것

    - 사건, 상태도, 조건, 활동 파악
  - 기능 모델링(Functional Modeling) : 자료 흐름도(DFD : Data Flow Diagram)를 이용하여 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 것

    - 객체 간의 자료 흐름도



- 소프트웨어 유지 보수 : 소프트웨어가 인수, 설치된 후 발생하는 모든 공학적 작업
  - 원인에 따른 분류
    - 수리(Corrective) 보수(수정, 하자 보수) : 소프트웨어 테스팅 동안 밝혀지지 않은 모든 잠재적인 오류를 수정하기 위한 보수 형태, 오류의 수정과 진단 과정이 포함된다.
    - 적응(Adaptive) 보수(환경 적응)
    - 완전화(Perfective) 보수(기능 개선)
    - 예방(Preventive) 보수(예방 조치)
  - 형상 관리(Configuration Management) : 소프트웨어에 가해지는 변경을 제어 관리하는 것
  - 소프트웨어 비용 중 가장 많이 소요된다.



- 중앙 집중형 팀 : 프로젝트 팀의 목표 설정 및 의사결정 권한이 리더에게 주어진다.
  - 중앙 집중식 구조, 리더의 개인적 능력이 가장 중요하다.


- 민주주의적 팀 (분산형 팀) : 팀 구성원 간의 의사 교류를 활성화시키므로 팀 구성원의 참여도와 만족도를 증대시키고 이직률을 낮춘다. 



- 프로젝트를 시작하기 전에 추정해야 하는 항목
  - 얼마나 오래? 얼마나 많은 노력이 요구? 얼마나 많은 사람이 참여? 등등..
  - 유지 보수 비용은 프로젝트 완성 후에 추정해야 한다.
- 구조적 프로그래밍에서 사용하는 기본적인 제어 구조

  - 순차(Sequence) : 명령을 순서대로 나열한다.
  - 선택(Selection) : 특정 논리에 기초하여 명령을 선택한다.
  - 반복(Repetition, Iteration) : 순환을 제공한다.
- 소프트웨어 품질 관리 기술

  - 품질 목표 : 정확성 (Correctness), 신뢰성, 효율성, 무결성 (Integrity), 유지보수성, 유연성 (Flexibility), 이식성 (Portability) 등
- 소프트웨어 검사 단계 순서

  - 단위 검사(Unit Test) > 통합 검사(Integeration Test) > 검증 검사(Validation Test) > 시스템 검사(System Test)
    - 단위 검사
      - Black Box Test
        - Comparison Testing : 여러 버전의 프로그램에 동일한 검사 데이터를 제공하여 동일한 결과가 출력되는지 검사하는 기법
      - White Box Test : 프로그램의 구조에 의거하여 테스트, 원시 코드의 모든 문장을 한 번 이상 수행함으로써 진행
        - 제품의 내부 요소들이 명세서에 따라 수행되고 충분히 실행되는가를 보장하기 위한 검사이다.
        - 조건 검사, 루프 검사, 데이터 흐름 검사 등이 있다.
        - 모듈 안의 작동을 직접 관찰한다.
        - 프로그램 원시 코드의 논리적인 구조를 커버하도록 테스트 케이스를 설계한다.
    - 검증(공정 확인) 검사 (Validation)
      - Alpha test : 신제품에 대한 제작 회사의 자체 테스트
      - Beta test : 정해진 사용자 계층이 써보도록 하는 테스트
- 자동화 추정 도구 : 비용 산정의 자동화를 위해 개발된 도구로는 SLIM과 ESTIMACS가 있다.

  - SLIM : Rayleigh-Norden 곡선과 Putnam 예측 모델을 기초로 하여 개발된 자동화 추정 도구
  - ESTIMACS : 다양한 프로젝트와 개인별 요소를 수용하도록 FP 모형을 기초로 하여 개발된 자동화 추정 도구
- 소프트웨어 품질 보증

  - FTR

    - 제품의 검토에만 집중하라.
    - 의제를 제한하여 진행하라.
    - 논쟁과 반박을 제한하라.
    - 문제 영역을 명확히 표현하라
    - 참가자 수를 제한하고 사전 준비를 강요하라.
    - 자원과 시간 일정을 할당한다.
    - 검토 과정과 결과를 재검토하라. (모든 검토자들을 위해 의미있는 훈련을 행한다.)
- 나선형 모형 개발 단계
  1. Planning(계획 및 정의)
  2. Risk Analysis(위험 분석)
  3. Engineering(공학적 개발, Development)
  4. Customer Evaluation(고객 평가) : 고객 평가와 검증 과정을 수행하여 개발된 결과를 평가한다.
- CPM 네트워크

  - 여기서 임계 경로는 최장 경로를 의미한다.
- 소프트웨어 재사용

  - 장점 : 개발 시간과 비용을 단축, 품질 향상, 프로젝트 실패의 위험 감소, 시스템 구축에 대한 지식 공유
  - 단점

    - 어떤 것을 재사용할 것인지를 선택해야 한다.
    - 시스템에 공통적으로 사용되는 요소들을 발견해야 한다.
    - 프로그램의 표준화가 미흡하다.
    - 새로운 개발 방법론을 도입하기 어렵다.
    - 재사용을 위한 관리 및 지원이 부족하다.
    - 기존 소프트웨어에 재사용 소프트웨어를 추가하기 어렵다.
    - 프로그램 언어가 종속적이다.
    - 소프트웨어 요소의 내부 뿐만 아니라 인터페이스 요구사항에 대한 이해가 필요하다.
    - 라이브러리 안에 포함시킬 재사용 요소의 명확한 결정 기준이 없다.
- 컴포넌트 (Component) : 소프트웨어 재사용과 관련된 객체들의 모임, 대규모 재사용 단위
- 컴포넌트 재사용을 위한 컴포넌트 기반 개발 활동

  - 후보 컴포넌트가 요구되는 기능을 수행하는지 조사하기 위해 컴포넌트 검증을 수행한다.
  - 컴포넌트 라이브러리가 컴포넌트 확장 언어를 제공하면 그레이 박스 랩핑을 적용할 수 있다.
  - 어플리케이션 구현을 위해 검증, 제작, 개발된 컴포넌트들을 조립하는 컴포넌트 합성을 수행한다.
- 폭포수 모형 (Waterfall Model) : 가장 오래된 모형으로 많은 적용 사례가 있지만 요구 사항의 변경이 어려우며, 각 단계의 결과가 확인되어야 다음 단계로 넘어간다. 선형 순차적 모형으로 고전적 생명 주기 모형이라고도 한다.
- 비용 예측 방법 (비용 추정 모형)

  - 원시 프로그램의 규모에 의한 방법

    - COCOMO (COnstuctive COst MOdel) : 보엠(B. Bohem)이 제안한 소프트웨어 개발 비용의 평가 및 산정 방법, 3 단계 방법이 있다.

      - 비용(Cost) 산정 과정

        - KDSI (or KLOC) 측정
        - 개발 노력 승수 (Development Effort Multifliers) 결정
      - 비용 산정 유형 : KDSI (Delivered Source Instruction / KLOC)을 기준으로 하며 양에 따라 나뉜다.

        - 임베디드형 (Embedded (초대형 규모)) : 초대형 규모의 트랜잭션 처리 시스템이나 운영체제 등의 소프트웨어를 개발하는 유형
        - 중간형 (Semi-detached (대규모))
        - 단순형 (Organic (소규모))
      - 개발 유형에 따라 Basic, Intermediate, Detailed 모델이 있다.
        - Detailed 모델의 경우 Intermediate 모델을 확장하여 프로젝트의 각 페이스에 노력 승수를 추가하였다.
  - Putnam 모형 : 소프트웨어 개발 프로젝트의 생명 주기 전 과정동안에 사용될 노력의 특수한 분포를 가정해주는 동적 다변수 모델
  - 기능 점수(FP : Functional Point) 모형 : Albrecht가 제안함. 소프트웨어의 기능을 증대시키는 요인 별로 가중치를 부여하고 요인 별 가중치를 합산하여 총 기능을 점수로 산출한다. 총점과 영향도를 이용하여 기능 점수를 구한 후, 이를 이용해서 비용을 산정하는 기법
- 자료 사전 (Data Dictionary)

  - 정의 - =, 연결 - +, 생략 - optional (), 선택 - [], 반복 - {}, 설명 - **
- CORBA에서 인터페이스 정의 언어는 IDL이다.


# 5. Data Communication


- 프로토콜의 기본 요소


    - 구문 (Syntax) : 데이터 형식, 부호화(Coding), 신호 레벨(Signal Level) 등을 정의
    - 타이밍 (Timing) : 통신 속도의 조정, 메시지의 순서 제어 등을 정의
    - 의미 (Semantics) : 정보 전송 제어와 오류 관리를 위한 제어 정보를 정의

- 전송 제어 절차 : 회선 접속 > 데이터 링크 확립 > 정보 전송 > 데이터 링크 해제 > 회선 절단

  - 문자 동기 전송 방식 (동기식 문자 지향 프로토콜 프레임, 전송 제어 문자)
    - DLE (Data Link Escape) : 데이터 투과성(Data Transparent, 데이터 투명성)을 위해 삽입되는 제어 문자, 전송 제어 문자임을 알린다.
    - SYN : 문자 동기 유지를 위해 삽입되는 제어 문자
    - STX : 본문 시작을 위해 삽입되는 제어 문자
    - ETX : 본문 종료를 위해 삽입되는 제어 문자
    - ACK(ACKnowledge) : 수신 측에서 송신 측으로 보내는 긍정 응답 문자
    - NAK(Not AcKnowledge) : 수신 측에서 송신 측으로 보내는 부정 응답 문자
    - EOT(End Of Transmission) : 전송 종료 및 데이터 링크 해제
    - SOH(Start Of Heading) : 헤딩 시작
    - ETB : 전송 블록 종료
    - BCC : 오류 검사를 수행

- 자동 반복 요청 (ARQ) : 오류 발생 시 수신 측은 오류 발생을 송신 측에 통보하고, 송신 측은 오류 발생 블록을 재전송하는 모든 절차를 의미한다.

  - 정지-대기(Stop and Wait) ARQ : 송신 측에서 한 개의 블록을 전송한 후 수신 측으로부터 응답을 기다리는 방식

  - 연속적(Go-Back-N) ARQ : 오류가 발생한 블록 이후의 모든 블록을 재전송한다.

    = Sliding Window : 수신 측으로부터 이전에 송신한 프레임에 대한 ACK를 받으면 송신 윈도우가 증가하고 NAK를 받으면 송신 윈도우가 감소하는 방식

    - 흐름 제어 방식에서 한 번에 여러 개의 프레임을 전송할 경우 효율적인 기법이다.

  - 선택적 재전송(Selective Repeat) ARQ : 오류가 발생한 블록만을 재전송, 수신 측에서 데이터를 처리하기 전에 원래 순서대로 조립해야 하여 더 복잡한 논리 회로와 큰 용량의 버퍼가 필요하다.

  - 적응적(Adaptive) ARQ



- LAN (Local Area Network)
  - 단일 건물 내에 설치되고, 패킷 지연이 최소화된다.
  - 확장성과 재배치성이 좋고 경로 설정이 불필요하다.
  - 네트워크 내에 다른 기기와 통신이 가능하다.
  - 광대역 전송 매체의 사용으로 고속 통신이 가능하다.
- ISDN (Integrated Service Digital Network) : 컴퓨팅, 교환, 디지털 전송 장치 간의 구분이 없어지고 음성, 데이터 및 이미지 전송에 동일한 디지털 기술이 적용된 통합 시스템 네트워크
  - 종합 정보 통신망
  - 발신 가입자로부터 수신자까지의 모든 전송, 교환 과정이 디지털 방식으로 처리된다.
  - 음성과 비음성, 영상 등의 서비스를 종합적으로 처리한다.
- 부가 가치 통신망 (VAN : Value Added Network) : 통신 회선을 기간 통신 사업자로부터 임차하여 망을 구축하고 이를 이용하여 축적된 정보를 서비스하는 통신망
  - 전송 기능 : VAN의 기본적인 기능
  - 교환 기능 : 사용자 간의 정보 전송 기능
  - 통신 처리 기능 : 프로토콜(미디어) 변환, 전자 사서함(Mail Box), 동보 통신
  - 정보 처리 기능 : 정보 검색 서비스, 소프트웨어 개발, 데이터베이스 구축
- 대역폭 효율 : 단위 대역폭 당 전송률, 주파수 대역폭 이용 효율
- 디지털 변조 (디지털 데이터 -> 아날로그 신호) 방식의 종류

  - 진폭 편이 변조 (ASK : Amplitude Shift Keying) : 서로 다른 진폭을 대비시켜 아날로그 신호를 만든다.
  - 주파수 편이 변조 (FSK : Frequency Shift Keying) : 서로 다른 주파수를 대비시켜 아날로그 신호를 만든다.
  - 위상 편이 변조 (PSK : Phase Shift Keying) : 서로 다른 위상을 대비시켜 아날로그 신호를 만든다.
    - 2 위상 편이 변조 (DPSK) : 각 신호 간의 위상 차는 180도
    - 4 위상 편이 변조 (QPSK) : 각 신호 간의 위상 차는 90도, 대역폭 효율은 2 bps/Hz
    - 8 위상 편이 변조 (ODPSK) : 각 신호 간의 위상 차는 45도
    - 각 위상끼리 비교했을 때 지수 배만큼 오류 확률이 높다. (2진 - 8진 : 3배)
  - 진폭 위상 변조 (QAM : Quadrature Shift Keying) : 서로 다른 진폭과 위상을 대비시켜 아날로그 신호를 만든다.
    - 256 QAM의 대역폭 효율은 8 bps/Hz
- 디지털 부호화 기술

  - ADPCM : 음성 신호의 통계적 특성을 이용하여 적응적으로 예측하고 양자화하는 방식
- 변조 (아날로그 -> 아날로그)

  - 진폭 변조 (AM) : 신호의 높낮이(진폭)를 변조
  - 주파수 변조 (FM) : 신호의 주기(주파수)를 변조
  - 위상 변조 (PM) : 신호의 각도, 모양을 변조
- PCM (Pulse Code Modulation) : 아날로그 데이터를 디지털 신호로 변환하여 전송하고, 수신 측에서 이를 다시 원래의 아날로그 데이터로 복원하는 방식

  - 과정 : 표본화 > 양자화 > 부호화 (변조 과정) > 복호화 > 여과화 (복조 과정)
  - 상호 부호 간 간섭(ISI) 측정을 위해 눈 패턴(Eye Pattern)을 이용
    - 눈 패턴(Eye Pattern) : 눈을 떴을 때의 좌우 폭은 수신파를 상호 부호 간 간섭없이 샘플링할 수 있는 주기가 된다.
      - 바람직한 샘플링 주기는 눈을 가장 넓게 뜬 경우로 출력 펄스의 폭 변동이나 펄스 위치의 변동이 클 수록 주기 간의 차는 커진다.
      - 타이밍 에러에 의한 시스템의 감도는 샘플링 시간의 변동에 따라 눈이 감기는 비율로 결정한다.
      - 눈을 뜬 상하의 높이는 특정한 샘플링 시간에 대한 잡음의 여유도이다.
      - 상호 부호 간 간섭이 심할 경우에는 눈 패턴의 윗 부분과 아랫 부분이 겹치게 되어 눈이 완전히 감기게 된다.
      - 입력 신호가 완전히 랜덤하고 시스템이 선형적이라면 모든 눈의 모양은 동일하지만 실제로는 전송 채널이 비선형적이므로 눈 패턴은 비대칭이다.
- 양자화 레벨 (양자화 Step 수) = 2^((표본 당) 전송 비트 수)



- 전송 속도[bps] = 변조 속도[baud] * 신호 당 전송 비트[bit]

- 나이키스트 공식 : 표본화 횟수 = 2 * 최고 주파수, 표본화 주기 = 1 / 표본화 횟수
  $$
  bps = Blog_2(1 + S / N)
  $$

- 2^m 위상 변조는 한 번에 m 개의 신호 비트를 전송한다.



- 다중화기 (Multiplexer)

  - 시분할 다중화 (TDM : Time Division Multiplexing) : 한 전송로를 일정한 시간 폭으로 나누어 사용하는 기법, 대역폭의 이용도가 높아 고속 전송에 유리하다.

    - 동기식 시분할 다중화기 : 전송 매체 상의 전송 프레임마다 해당 채널의 시간 슬롯이 고정적으로 할당된다. - 전송할 데이터가 없는 단말 장치에도 타임 슬롯이 고정적으로 할당되므로 효용성이 떨어진다.
    - 비동기식(통계적) 시분할 다중화기 (ATDM : Asyncronous TDM) : 전송할 데이터가 있는 채널만 차례로 시간 슬롯을 할당하여 전송한다.

      - 다중화된 회선의 데이터 전송률이 접속 장치들의 데이터 전송률의 합보다 적다.
    - 주파수 분할 다중화기 (FDM : Frequency Division Multiplexer) :  다중화기 자체에 변복조 기능이 포함되어 있어 모뎀을 따로 설치할 필요가 없다.



- 잡음 (Noise) : 디지털 데이터를 전송하는 경우 중요한 오류 발생의 원인이 된다.
  - 백색 잡음 (White Noise) : 전송 매체 내부의 온도에 따라 발생하는 잡음, 열 잡음이라고도 한다.
  - 상호 변조 잡음 (Intermodulation Noise) : 서로 다른 주파수들이 하나의 전송 매체를 공유할 때 이 주파수들이 서로의 합과 차의 신호를 발생시킴으로써 발생되는 잡음
  - 누화 잡음 (Crosstalk Noise) : 상호 인접한 전송 매체의 전자기적 상호 유도 작용에 의해 발생되는 잡음
  - 충격성 잡음 (Impulse Noise) : 외부의 전자기적 충격이나 기계적인 통신 시스템에서의 결함 등에 의해 발생하는 잡음, 비연속적이고 불규칙한 진폭을 가지며 순간적으로 높은 진폭이 발생한다.



- OSI 7 계층
  - 응용 (Application) : 사용자가 OSI 환경에 접근할 수 있도록 서비스를 제공한다.
    - 데이터 전송 단위 : 메시지 (Message)
  - 표현 : 코드 변환, 구문 검색, 암호화, 형식 변환, 압축
    - 데이터 전송 단위 : 메시지 (Message)
  - Session
    - 데이터 전송 단위 : 메시지 (Message)
  - 전송 (Transport) : 통신 양단 간(End to End) 투명한 데이터 전송을 제공한다. 에러 제어 및 흐름 제어를 담당한다.
    - TCP : 패킷의 다중화, 순서 제어, 오류 제어, 흐름 제어 기능, 스트림(Stream) 전송 기능을 제공
      - 데이터 전송 단위 : Segment
    - UDP : 데이터 전송 전에는 연결을 설정하지 않는 비연결형 서비스, 복구 기능, 수신 데이터 순서 재조정 불가
      - UDP 헤더 : Source Port Number, Destination Port Number, UDP Total Length, Checksum
      - 데이터 전송 단위 : Datagram
  - Network
    - IP : 데이터 그램을 기반으로 하는 비연결형 서비스, 패킷의 분해와 조립, 주소 지정, 경로 선택 기능을 제공
      - 비연결형 전송 서비스, 비신뢰성 전송 서비스, 데이터 그램 전송 서비스를 제공한다.
      - IP가 소속되어 있는 네트워크 주소와 브로드캐스트 주소 구하는 법
        - 네트워크 주소 : IP를 2진수로 표현하여 서브넷 마스크만큼의 자리까지 1로 채워진 주소와 AND 연산한 값
        - 브로드캐스트 주소 :  IP를 2진수로 표현하여 전부 1로 채워진 주소와 AND 연산한 값
        - 서브넷 마스크 : 네트워크 ID와 호스트 ID를 구별할 수 있다.
          - 클래스풀 서브넷 : 고정적인 클래스 범위
            - A 클래스 서브넷 마스크 : 255.0.0.0 / 8
            - B 클래스 서브넷 마스크 : 255.255.0.0 / 16
            - C 클래스 서브넷 마스크 : 255.255.255.0 / 24
            - 호스트 주소 범위 = 2^(32 - 서브넷 비트) - 2
    - X.25 etc..
    - 데이터 전송 단위 : 패킷 (Packet)
    - 패킷 조립 분해기 (PAD : Packet Assembler Disassembler) : 데이터 전송을 위해 데이터 흐름을 분리된 패킷들로 나누고 수신 측에서는 패킷을 다시 재조립하는 하드웨어 또는 소프트웨어 장치
      - 주로 X.25 회선의 인터페이스에 사용된다.
  - Data Link : 물리적 연결을 이용해 신뢰성 있는 정보를 전송하려고 프레임의 동기화, 오류 제어, 흐름 제어, 에러 검출 및 정정 등의 전송 에러를 제어하는 계층
    - HDLC 전송 제어 : SDLC 절차를 1974년도에 ISO가 채택한 데이터 링크 제어 절차
      - 구조 : Flag / 주소부 / 제어부 / 정보부 / FCS / Flag
      - 데이터 전송 모드 (링크 구성 방식)
        - 정규(표준) 응답 모드(NRM : Normal Response Mode) : 반이중 통신을 하는 Point to Point or Multipoint / 불균형 링크 구성에 사용한다.
        - 비동기 응답 모드(ARM : Asyncronous Response Mode) : 전이중 통신을 하는 Point to Point 불균형 링크 구성에 사용한다.
        - 비동기 균형(평형) 모드(ABM : Asyncronous Balanced Mode) : 전이중 통신을 하는 Point to Point 균형 링크 구성에 사용한다.
        - 반이중 NRM / (전이중) 불균형 ARM / (전이중) 균형 ABM
      - 프레임의 종류
        - I-Frame (정보 프레임) : 제어부가 0으로 시작, 사용자가 데이터를 전달하거 피기백킹 기법을 통해 데이터에 대한 확인 응답을 보낼 때 사용
        - S-Frame (감독 프레임) : 제어부가 10으로 시작, 오류 제어와 흐름 제어를 위해 사용
        - U-Frame (비번호 프레임) : 제어부가 11로 시작, 링크와 동작 모두 설정과 관리, 오류 회복을 수행
    - LAP-B (Link Access Procedure-Balanced) : HDLC 프로토콜로부터 X.25 패킷 교환을 위해 개발된 점 대 점(Point to Point) 데이터 링크 접속용 ITU-T 프로토콜 표준
      - 데이터 링크 계층에서 전송 제어 절차를 규정한다.
      - HDLC를 기반으로 하는 비트 위주 데이터 링크 제어 프로토콜
      - X.25 패킷 교환망 표준의 한 부분으로 ITU-T에 의해 제정되었다.
    - LLC, LAPD, PPP, ADCCP etc..
    - 데이터 전송 단위 : 프레임 (Frame)
  - 물리 (Physical) : 물리적인 장치와 인터페이스가 전송을 위해 필요한 기계적, 전기적, 기능적, 절차적 기능을 정의
    - (전송 매체의 유형, 전송로의 연결, 유지 및 해제 등)
    - RS-232C, X.21 etc..
    - 데이터 전송 단위 : 비트 (Bit)
- TCP/IP 4 계층

  - 응용 : Telnet, FTP, SMTP, SNMP HTTP, DNS, WAP etc..
  - 전송 : 호스트 간 신뢰성 있는 통신을 제공한다.

    - TCP, UDP, RTP, RTCP
  - 인터넷 (IP 계층) : IP(Internet Protocol), IGMP(Internet Group Message Protocol)
    - 인터넷 제어 메시지 프로토콜 (ICMP : Internet Control Message Protocol) : 통신 중 발생한 오류 처리와 경로 변경 등을 위한 제어 메시지 관리
    - ARP (Address Resolution Protocol) : 논리 주소를 물리 주소로 변환시켜 주는 프로토콜 (MAC -> IP)
    - RARP (Reverse Address Resolution Protocol) : 물리 주소를 논리 주소로 변환시켜 주는 프로토콜 (IP -> MAC)
  - 네트워크 액세스 : Ethernet, IEEE 802, HDLC, X.25, RS-232C, PPP etc..



- X.25 계층
  - 물리 : OSI 7 계층 중 물리 계층에 해당
  - 링크 : OSI 7 계층 중 데이터 링크 계층에 해당
  - 패킷 : OSI 7 계층 중 네트워크 계층에 해당
- 패킷 교환망의 기능

  - 다중화 : 효율적인 전송을 위해 넓은 대역폭(고속 전송 속도)을 가진 하나의 전송 링크(회선)를 통해 여러 신호(데이터)를 동시에 실어보내는 기술
  - 논리 채널 : 가상 회선 설정
  - 오류 제어 : 오류 검출, 정정
  - 트래픽 제어 (Traffic Control) 기법 : 패킷 교환망에서 유통되는 패킷의 수를 적절히 조철해 통신망을 효율적으로 사용하기 위한 제어 기법, 가장 효율적인 경로를 선택
    - 흐름 제어 (Flow Control) : 패킷 수를 적절히 조절하여 전체 시스템의 안정성을 기하고 서비스의 품질 저하를 방지한다.
    - 혼잡 제어 (Congestion Control)
    - 교착 상태 방지 (Deadlock Avoidance)
  - 순서 제어 : 패킷의 송, 수신 순서가 같도록 제어한다.



- Topology
  - Ring형 : 서로 이웃한 컴퓨터와 단말 장치끼리 Point to Point 방식으로 연결된 형태, 두 노드 사이에 채널이 고장나면 전체 시스템에 영향을 미친다.
  - 망형
  - 성(Star)형
  - 계층형
- 경쟁(Contention) 방식 : 데이터 전송을 하고자 하는 모든 단말 장치들이 서로 대등한 입장에 있으며, 송신 요구를 먼저 한 쪽이 송신권을 갖는 방식, 회선에 접근하기 위해 서로 경쟁한다.

  - 표본화 이론 : 어떤 신호 f(t)가 있을 때, f(t)가 갖는 최고 주파수의 두 배 이상으로 채집하면, 채집된 신호는 원래의 신호가 가지는 모든 정보를 포함한다.
- 순방향(전진) 에러 수정 (FEC : Forward Error Correction) : 오류 수정을 위한 비트를 데이터에 부가하여 전송하고 수신측에서 오류 발생을 검출하고 수정하는 방식

  - 해밍 코드 방식과 상승 코드 검사 방식이 대표적이다.
  - 연속적인 데이터 전송이 가능하다.
  - 스스로 오류를 검출하고 수정하기 때문에 역채널이 필요하지 않다.
  - CRC 코드 등
- IPv6의 주소 체계 : 링크 로컬 범위 모든 노드에서 멀티캐스트 주소 사용

  - Unicast
  - Anycast
  - Multicast
- 10Base-5 Ethernet : 10Mbps의 전송 속도, Baseband 전송 방식, 동축 케이블을 전송 매체로 이용, 한 세그먼트 최대 전송 거리는 500m
- 데이터 교환 방식

  - 축적 교환 방식 : 송신 측에서 전송한 데이터를 송신 측 교환기에 저장시켰다가 이를 다시 적절한 통신 경로를 선택하여 수신 측 터미널에 전송하는 방식
    - 수신 노드에서 패킷을 재순서화하는 과정이 필요하다.
    - 메시지 교환 : 송신 데이터와 수신 순서가 불일치한다.
      - 전송 도중 오류 발생 시 메모리에 축적되어 있는 복사본을 재전송 가능하다.
      - 각 메시지마다 수신 주소를 붙여서 전송한다.
    - 패킷 교환 : 저장 전달 방식을 사용, 전송하려는 패킷에 헤더가 부착된다.

      - 가상 회선
      - 데이터 그램
  - 회선 교환 방식 : 통신을 원하는 두 지점을 교환기를 이용하여 물리적으로 접속시키는 방식

    - 노드와 노드 간에 물리적으로 전용 통신로를 설정해야 한다.
    - 고정된 대역폭으로 데이터를 전송한다.
    - 회선이 설정되어 통신이 완료될 때까지 회선은 물리적으로 접속되어 있다.
    - 실시간 대화형에 적합하다.
- Routing Protocol

  - 최단 경로 우선 프로토콜 (OSPF : Open Shortest Path First) : 인터넷 프로토콜(IP : Internet Protocol) 네트워크를 위한 Link State Routing Protocol

    - Multicasting을 지원한다.
    - 네트워크 변화에 신속하게 대처할 수 있다.
    - 최단 경로 탐색에 다익스트라(Dijkstra) 알고리즘을 사용한다.
    - 내부 라우팅 프로토콜의 일종으로 링크 상태 알고리즘을 사용한다.
    - 대규모 네트워크에 적합하다.
  - RIP (거리 벡터 라우팅 프로토콜) : 패킷을 목적지까지 전달하기 위해 사용한다.
  - BGP
- 라우팅 테이블이 가지고 있는 경로 정보의 세 가지 요소 : 다음 홉, 메트릭, 수신지 네트워크 주소
- Hand off : 이동 통신에서 사용자가 셀 경계를 지나면서 신호의 세기가 작아지거나 간섭이 발생하여 통신 품질이 떨어져 현재 사용 중인 채널을 끊고 다른 채널로 이동하는 것.

  - 정확히는 다른 채널로 이동하는 것은 Hand over, 채널 접속 종료를 Hand off라고 한다.
- 1 Octet = 8 Bit = 1 Byte
- ATM cell의 헤더는 (40 bit = 5 byte = 5 octet)로 이루어져 있고 유로부하(Payload)는 (48 byte = 48 octet)
- SONET(Syncronous Optical Network) : 광전송망 노드와 망 간의 접속을 표준화한 것

  - 다양한 전송 기기를 상호 접속하기 위한 광신호와 인터페이스 표준을 제공한다.
  - STS-12의 기본 전송 속도는 622.08 Mbps이다.
- FRP (Frame Relay Protocol) : 프레임 중계 서비스와 프레임 교환 서비스를 제공한다.
- 해밍 코드 (Hamming Code) : 전송 비트 중 2^n번 째 비트는 오류 검출을 위한 패리티 비트(해밍 비트)이다.
- Hamming Distance >= 2 * (정정 가능한 오류 개수) + 1, (검출 가능한 오류 개수) = Hamming Distance - 1
- NRZ (None Return to Zero) 전송 부호

  - NRZ-L (-Level) : 0이 High Level, 1이 Low Level, 디지털 논리 회로에서 광범위하게 사용된다.
  - NRZ-M (-Mark) : 1이 전압 변환, 0이 전압 변환 없음, 1인 경우에만 비트 간격의 중간에서 전이 발생
  - NRZ-S (-Space) : 1이 전압 변환 없음, 0이 전압 변환, 0인 경우에만 비트 간격의 중간에서 전이 발생
  - NRZ-I (-Inversion) : 0에서 1로, 1에서 0으로 비트가 변할 때만 비트 간격의 중간에서 변화한다.
- Tunneling : IPv6를 사용하는 두 컴퓨터가 서로 통신하기 위해 IPv4를 사용하는 네트워크 영역을 통과해야 할 때 사용되는 전략

  - IPv4를 사용하는 네트워크 영역을 통과하기 위해 패킷은 IPv4 주소를 가져야만 한다.
  - IPv6 패킷은 네트워크 영역에 들어갈 때 IPv4 패킷 내에 캡슐화되고 나올 때 역캡슐화된다.
- VoIP (Voice over Internet Protocol) : IP 주소를 사용하는 네트워크를 이용하여 음성을 디지털로 변환하는 기술
- 유무선 프로토콜 스택 구조 : 광대역 통합 네트워크에서 VoIP 서비스를 제공하기 위한 프로토콜

  - Call & Management, H.323, SIP, MGCF/MEGACO
- SIGTRAN (SIGnaling TRANsport) : 인터넷 망(IP Network)과 유선 전화망(PSTN : Public Switched Telephone Network, 공중 교환 전화망) 간을 상호 연동시키는데 사용되는 시그널링 프로토콜
- 다중 접속 방식

  - CDMA : 주파수나 시간을 모두 공유하면서 각 데이터에 특별한 코드를 부여하는 방식

    - 산악 지형, 혼잡한 도심 지역에서도 통화 품질이 우수하다.
    - 시스템의 포화 상태로 인한 통화 단절 및 혼선이 적다.
    - 실내 또는 실외에서 넓은 서비스 권역을 제공한다.
    - 배경 잡음을 방지하고 감쇄시킴으로써 우수한 통화 품질을 제공한다.
  - 토큰 패싱 (Token Passing)
  - CSMA / CD : 자유 경쟁으로 채널 사용권을 확보하는 방법으로 노드 간의 충돌을 허용한다. 이더넷(Ethernet)이라고도 한다.

    - 통신 회선이 사용 중이면 일정 시간 대기
    - 데이터가 없을 때만 데이터 송신
    - 송신 중에도 전송로 상태를 계속해서 감시한다.
    - 일반적으로 버스형 LAN에 사용된다.
    - 일정 길이 이하의 데이터 송신 시 충돌 검출이 불가능하다.
    - 전송량이 적을 때 매우 효율적이고 신뢰성이 높다.
    - 충돌 발생 시 다른 노드에서는 데이터를 전송할 수 없다.
    - 지연 시간 예측이 어렵다.
    - 토큰 패싱 방법에 비해 구현이 간단하다.
    - 충돌 및 채널 경쟁을 위한 기법 : Non-Persistent, 1-Persistent, p-Persistent
- ALOHA : 최초의 라디오 패킷(Radio Packet) 통신 방식을 적용한 컴퓨터 네트워크 시스템
- 무선 랜 규격 : IEEE 802.11
- Polling : 불균형적인 멀티 포인트 링크 구성 중 주 스테이션이 각 부 스테이션에게 데이터 전송을 요청하는 회선 제어 방식