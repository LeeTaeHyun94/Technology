# [Engineer Information Processing]

# 데이터베이스 개념

## 1. 데이터베이스의 정의

데이터베이스 : 특정 조직의 업무를 수행하는 데 필요한 상호 관련된 데이터들의 모임

* 통합 (Integrated) 데이터 : 검색의 효율성을 위해 중복이 최소화된 데이터의 모임
* 저장 (Stored) 데이터 : 컴퓨터가 접근 가능한 저장 매체에 저장된 데이터
* 운영 (Operational) 데이터 : 조직의 목적을 위해 존재 가치가 확실하고 반드시 필요한 데이터
* 공유 (Shared) 데이터 : 여러 응용 프로그램들이 공동으로 사용하는 데이터

## 2. 데이터베이스의 특징

- 실시간 접근성 (Real Time Accessibility) : 사용자의 질의에 대하여 즉시 처리하여 응답하는 특징
- 계속적인 진화 (Continuous Evolution) : 삽입, 삭제, 갱신을 통하여 항상 최근의 정확한 데이터를 동적으로 유지하는 특징
- 동시 공유 (Concurrent Sharing) : 여러 사용자가 동시에 원하는 데이터를 공용할 수 있는 특징
- 내용에 의한 참조 (Content Reference) : 데이터베이스에 있는 데이터를 참조할 때 튜플의 주소나 위치에 의해서가 아니라 사용자가 요구하는 데이터 내용에 따라 참조하는 특징
- 논리적 독립성 (Logical Dependency) : 응용 프로그램과 데이터베이스를 독립시킴으로써 데이터의 논리적 구조를 변경시키더라도 응용 프로그램은 변경되지 않는 특징
- 물리적 독립성 (Physical Dependency) : 응용 프로그램과 물리적 장치를 독립시킴으로써, DBMS의 성능 향상을 위해 새로운 디스크를 도입하더라도 응용 프로그램에는 영향을 주지 않고 데이터의 물리적 구조만 변경될 수 있는 특징

## 3. 데이터 언어 (Data Language)

데이터 언어는 데이터베이스를 구축하고 이용하기 위한 DBMS의 통신 수단

데이터 언어는 기능과 사용 목적에 따라 나뉜다.

- 데이터 정의어 (DDL : Data Definition Language) 
  - 데이터베이스 구조, 데이터 형식, 접근 방식 등 데이터베이스를 구축하거나 변경할 목적으로 사용하는 언어
  - DDL 컴파일러가 컴파일한 후 데이터 사전에 저장한다.
  - DDL의 기능
    - 데이터베이스의 논리적, 물리적 구조를 정의 및 변경한다.
    - 스키마에 사용되는 제약 조건을 정의한다.
    - 데이터의 물리적 순서를 규정한다.
- 데이터 조작어 (DML : Data Manipulation Language)
  - 데이터 처리를 위해서 응용 프로그램과 DBMS 간의 인터페이스를 위한 언어
  - 데이터 처리를 위한 연산의 집합으로 데이터의 검색, 삽입, 삭제, 갱신 연산 등이 있다.
  - DML의 형태
    - 절차적 데이터 조작어 : 사용자가 어떤(What) 데이터를 필요로 하는지는 물론이고 필요한 데이터를 어떻게(How) 구하는지를 명시하는 언어, 배우기도 어렵고 사용하기도 어렵다.
    - 비절차적 데이터 조작어 : 사용자가 어떤(What) 데이터가 필요한지만을 명시하고 어떻게(How) 구하는지는 명시하지 않는 언어, 배우기 쉽고 사용하기 쉬우나 코드가 비효율적이다.
- 데이터 제어어 (DCL : Data Control Language)
  - 보안 및 권한 제어, 무결성, 회복, 병행 제어를 위한 언어
  - DCL의 기능
    - 데이터 보안 : 권한이 없는 접근으로부터 데이터베이스를 보호
    - 데이터 무결성 : 의미적인 측면에서 데이터가 정확하고 완전함을 의미한다. 사용자가 무결성 제약 조건을 정의하면 DBMS는 데이터를 삽입, 삭제, 갱신할 때마다 제약 조건을 자동적으로 검사한다.
    - 데이터 회복 : 시스템 오류 등으로부터 데이터베이스를 회복
    - 병행 제어 : 여러 사용자가 동시에 데이터베이스를 공유할 수 있도록 한다.

## 4. 데이터베이스 사용자

- 데이터베이스 관리자 (DBA : DataBase Administrator)
  - DDL과 DCL을 통해 데이터베이스를 정의하고 제어하는 사람 또는 그룹
  - DBMS와 컴퓨터 시스템, 조직 내의 전산 업무에 상당한 지식을 보유해야 한다.
  - 데이터베이스 관리자의 임무는 데이터베이스를 설계, 관리, 운용 및 통제하며, 효율성과 경제적인 효용성을 높이기 위해 시스템을 감시하고 성능을 분석
- 데이터 관리자 (Data Administrator)
  - 하나의 기업 또는 조직 내에서 데이터에 대한 정의, 체계화, 감독 및 보안 업무를 담당할 뿐 아니라 기업 또는 조직 전반에 걸쳐 존재하는 데이터에 대한 관리를 총괄하고 정보 활용에 대한 중앙 집중적인 계획 수립 및 통제를 수행
  - 전사적으로 수립된 데이터 표준 원칙, 데이터 표준, 데이터 표준 준수 여부 관리 등을 위해서 데이터 관리자의 역할이 요구된다.
- 데이터 설계자 (Data Architect) 
  - 기업의 업무 수행에 필요한 데이터의 구조를 체계적으로 정의하는 사람
  - 데이터 구조를 정의하기 위해 데이터 구조 전반에 걸쳐 데이터 구조 원칙, 정보, 관리 등을 정의
  - 데이터 표준, 데이터 관리 체계 등을 포함하는 데이터 영역을 분류하며, 이를 기준으로 데이터 모델 생성
- 응용 프로그래머 (Application Programmer)
  - 호스트 프로그래밍 언어에 DML을 삽입하여 데이터베이스에 접근하는 사람
  - 호스트 프로그래밍 언어를 사용할 수 있고, 데이터베이스 관리 시스템에 대해서도 어느 정도 알고 있는 전산 전문가를 말한다.
- 일반 사용자 (End User)
  - 질의어를 통해 DBMS에 접근하는 사람
  - 컴퓨터나 DBMS에 대한 지식이 없어도 된다.
  - 데이터 삽입, 삭제, 갱신, 검색 등의 목적으로 DBMS를 이용

# DBMS

## 1. 데이터베이스 관리 시스템의 개념

- 데이터베이스 관리 시스템은 사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해 주고 데이터베이스를 관리해주는 소프트웨어
- 데이터베이스 관리 시스템은 기존의 파일 시스템이 갖는 데이터의 종속성과 중복성의 문제를 해결하기 위해 제안된 시스템으로 모든 응용 프로그램들이 데이터베이스를 공유할 수 있도록 관리
- 기존 파일 시스템의 문제점
  - 데이터 종속성으로 인한 문제점 : 응용 프로그램과 데이터 파일 간에 상호 의존적인 관계가 존재하기 때문에 데이터 파일이 보조기억장치에 지장되는 방법이나 저장된 데이터의 접근 방법을 변경할 때 응용 프로그램도 같이 변경해야 하는 문제점이 있다.
  - 데이터 중복성으로 인한 문제점 : 중복된 데이터 간에 내용이 일치하지 않는 상황이 발생하여 일관성이 없어지고, 중복되어 있는 모든 데이터에 동등한 보안 수준을 유지하기가 어려우며, 제어의 분산으로 데이터의 정확성이나 무결성을 효율적으로 유지할 수 없다는 문제점이 있다.

## 2. 데이터베이스 관리 시스템의 필수 기능

- 정의 기능 (Definition Facility) : 데이터의 타입과 구조, 데이터가 데이터베이스에 저장될 때의 제약 조건 등을 명시하는 기능을 제공
- 조작 기능 (Manipulation Facility) : 체계적 데이터 처리를 위해 데이터 접근 기능(검색, 삽입, 삭제, 갱신 등)을 명시하는 기능을 제공한다.
- 제어 기능 (Control Facility) : 데이터의 정확성과 안전성을 유지하기 위해 무결성, 보안 및 권한 검사, 병행 제어 등을 명시하는 기능을 제공한다.

## 3. DBMS의 장, 단점

- 장점
  - 데이터의 논리적, 물리적 독립성이 보장된다.
  - 데이터를 공동으로 이용할 수 있다.
  - 데이터를 표준화할 수 있다.
  - 데이터의 무결성을 유지할 수 있다.
  - 데이터의 실시간 처리가 가능하다.
  - 데이터의 중복을 피할 수 있다.
  - 데이터를 통합하여 관리할 수 있다.
  - 데이터의 일관성을 유지할 수 있다.
  - 데이터의 보안을 유지할 수 있다.
  - 항상 최신의 데이터를 유지할 수 있다.
- 단점
  - 데이터베이스의 전문가가 부족하다.
  - 대용량 디스크로의 집중적인 접근으로 과부하가 발생
  - 전산화 비용 증가
  - 데이터의 백업과 회복이 어렵다.
  - 시스템이 복잡해진다.

## * 데이터 스트림 관리 시스템 (DSMS : Data Stream Management System)

무선 센서 네트워크나 인터넷 같은 통신 상에서 발생하는 대량의 스트림 데이터를 처리하고 관리하는 시스템

- 디스크의 릴레이션에 저장된 정적이고 영구적인 데이터를 처리하고 관리하기 위한 DBMS와는 달리 온라인 상의 데이터 스트림이라는 동적인 특성을 가진 데이터를 처리하고 관리하는 시스템
- 온라인 상에서 연속전인 질의를 실행하면서 실시간으로 데이터를 처리하고 관리하기 때문에 질의의 입력 순서에 따라 데이터의 처리 결과가 달라질 수 있다.

# 스키마 (Schema)

## 1. 스키마의 개념

- DB의 구조와 제약 조건에 관한 전반적인 명세(Specification)
- DB를 구성하는 데이터 개체(Entity), 속성(Attribute), 관계(Relationship) 및 데이터 조작 시 데이터 값들이 갖는 제약 조건 등에 관해 전반적으로 정의한다.
- 사용자의 관점에 따라 외부(External) 스키마, 개념(Conceptual) 스키마, 내부(Internal) 스키마로 나뉜다.

## 2. 스키마의 특징

- 데이터의 구조적 특성을 의미
- 데이터 사전에 저장된다.
- 현실 세계의 특정한 한 부분의 표현으로서 특정 데이터 모델을 이용해서 만들어진다.
- 데이터의 논리적 단위에 명칭을 부여하고 그 의미를 기술한다.

## * 데이터 사전 (Data Dictionary)

DB에 저장되어 있는 모든 데이터 개체들에 대한 정보를 유지, 관리하는 시스템

- 시스템 카탈로그라고도 한다.
- '데이터에 관한 데이터'가 저장되어 있다고 하여 메타 데이터라고도 한다.

## * 메타 데이터 (Meta Data)

실제 저장되는 데이터는 아니지만 저장되는 데이터와 직접 혹은 간접적으로 관계가 있는 정보를 제공하는 데이터

- 대표적인 메타 데이터 포맷
  - MARC (Machine Readable Cataloging) : 목록 레코드를 식별하여 축적, 유통할 수 있도록 코드화한 메타 데이터
  - DC (Dublin Core) : 네트워크 환경에서 각종 전자 정보를 기술하는 메타 데이터
  - ONIX (ONline Information eXchange) : 유통에 관한 통계와 체계적인 정보를 취급함으로써 정상적인 유통 및 관리를 위한 메타 데이터
  - MODS (Metadata Object Description Schema) : 디지털 도서관의 범용 서지 정보 표준 메타 데이터로서 MARC, DC, ONIX 등을 절충하여 상호운용성과 정밀성을 모두 만족
- 메타 데이터의 상호운용성을 확보하기 위한 방법
  - 자원을 하나의 표준적인 메타 데이터로 통합하여 표현하는 방법
  - 자원의 특성을 감안하여 다양한 메타 데이터 형식과 기술 구조를 인정하고 상호 매핑을 통해 해결하는 방법
  - MDR (Meta Data Registry) : 메타 데이터의 등록과 인증을 통하여 메타 데이터를 유지, 관리하며, 메타 데이터의 명세를 공유하는 레지스트리

## 3. 스키마의 3 계층

- 외부 스키마
  - 사용자나 응용 프래그래머가 각 개인의 입장에서 필요로 하는 DB의 논리적 구조를 정의한 것
  - 전체 DB의 한 논리적인 부분으로 볼 수 있으므로 서브 스키마라고도 한다.
  - 하나의 DBMS에는 여러 개의 외부 스키마가 존재할 수 있으며, 하나의 외부 스키마는 여러 개의 응용 프로그램이나 사용자에 의해 공유될 수 있다.
  - 동일한 DB에 대해서 서로 다른 관점을 정의할 수 있도록 허용
- 개념 스키마
  - 개체 간의 관계와 제약 조건을 나타내고 DB의 접근 권한, 보안 정책 및 무결성 규정에 관한 명세를 정의한 것
  - DB의 전체적인 논리적 구조로서, 모든 응용 프로그램이나 사용자들이 필요로 하는 데이터를 통합한 조직 전체의 DB 명세로서 하나만 존재
  - 스키마 = 개념 스키마
  - 기관이나 조직의 관점에서 DB를 정의한 것
  - DBA에 의해서 작성
- 내부 스키마
  - DB의 물리적 구조를 정의한 것
  - 물리적 저장 장치릐 관점에서 본 전체 DB의 명세로서 하나만 존재
  - 개념 스키마의 물리적 저장 구조에 대한 정의를 기술한 것
  - 시스템 프로그래머나 시스템 설계자가 보는 관점의 스키마

# DB 설계

## 1. DB 설계의 개념

- DB의 구조, DB 스키마를 개발하는 과정
- 요구 조건 분석 (Requirement Analysis), 개념, 논리, 물리적 설계, DB 구현의 단계를 순서대로 반복하여 수행
- DB 설계 시에는 DB의 구조에 치중하는 데이터 중심(Datadriven) 설계와 데이터 처리 및 응용에 치중하는 처리 중심(Processing-driven) 설계를 병행

## 2. 요구 조건 분석

- DB를 사용할 사람이 필요로 하는 용도를 파악하는 작업
- 사용자의 요구 조건을 수집하고 분석하여 공식적인 요구 조건 명세를 작성
- 수집하고 분석해야 할 요구 조건
  - 개체, 속성, 관계, 제약 조건 등과 같은 정적 정보 구조
  - 트랜잭션의 유형, 실행 빈도와 같은 동적 DB 처리 요구 조건
  - 기관의 경영 목표 및 정책, 규정과 같은 범기관적 제약 조건에 대한 요구 조건
- 작성된 요구 조건 명세는 주요 사용자 그룹과 함께 다시 검토하고 확인한 후 최종 시스템 명세로 확정

## 3. 개념적 설계

- 정보의 구조를 얻기 위하여 현실 세계의 무한성과 계속성을 이해하고, 다른 사람과 통신하기 위하여 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정
- 개념적 설계 단계에서는 개념 스키마 모델링과 트랜잭션 모델링을 병행하여 수행
- 개념 스키마 모델링은 데이터의 조직과 표현에 치중하기 때문에 데이터 중심 설계라 할 수 있고, 트랜잭션 모델링은 응용을 위한 데이터 처리에 치중하기 때문에 처리 중심 설계라 할 수 있다.
- 개념 스키마 모델링은 요구 조건 분석의 결과로 나온 요구 조건 명세를 기반으로 개념적 데이터 모델에서의 데이터 구조, 즉 개념 스키마를 기술하는 과정이다.
- 요구 조건 분석 결과로부터 개념적 데이터 모델을 유도하는 기본 원리는 추상화
- 추상화란 복잡한 것들을 단순화하는 것을 의미한다. 구체적인 추상화 방법으로는 여러 속성들을 그룹지어 하나의 개체로 만드는 집단화(Aggregation)와 공통 성질을 가진 여러 부류의 개체들을 보다 일반적이고 포괄적인 개체로 만드는 일반화(Genaralization)가 있다.
- 트랜잭션 모델링에서는 트랜잭션의 입,출력과 기능적 형태를 정의하는 트랜잭션 명세를 작성한다. 즉, 입력 데이터, 출력 데이터 그리고 제어의 기능적 흐름을 명세함으로써 트랜잭션을 개념적이고 시스템 독립적으로 정의할 수 있다.

## 4. 논리적 설계

- 현실 세계에서 발생하는 데이터 형태를 컴퓨터가 이해하고 처리할 수 있는 특정 DBMS가 지원하는 논리적 데이터 구조로 변환시키는 과정
- 논리적 데이터 모델에서의 데이터 구조, 즉 논리 스키마를 설계한다.
- 논리적 설계를 위해서는 먼저 특정 DBMS를 선정해야 한다. 특정 DBMS 선정 시, SW 획득, 유지, DB 구축 및 전환, 교육 및 운용 비용 등을 고려해야 한다.
- 관계형 DBMS를 선정한 경우에는 개념적 설계에서 기술한 ER 도형을 정형적인 규칙에 따라 릴레이션 스키마로 변환한다.
- 더욱 좋은 릴레이션 스키마를 만들기 위하여 정규화(Normaliztion) 과정을 수행한다.
- 개념적 설계에서 기술한 트랜잭션 명세로부터 트랜잭션의 전체적인 골격을 개발하고 인터페이스를 정의한다.

## 5. 물리적 설계

- 주어진 응용 프로그램에 대한 성능 향상을 위해 DB 파일에 대한 특정한 저장 구조와 접근 경로를 결정하는 과정
- 효율적이고 구현 가능한 물리적 DB 구조, 즉 물리 스키마를 설계하는 것이 목적
- 저장 구조를 위한 레코드의 양식, 순서, 저장 공간 등과 접근 경로를 위한 인덱싱, 클러스터링, 해싱 등의 설계가 포함된다.
- 물리적 설계를 위하여 특정 DBMS 뿐만 아니라 특정 HW 및 OS의 특정도 고려해야 한다.
- 효과적인 물리적 설계를 위해 DB 트랜잭션을 요청해서 응답을 얻기까지의 응답 시간, DB 파일과 접근 경로 구조에 대한 저장 공간의 효율성, 일정 단위 시간 동안 처리되는 트랜잭션의 평균 수인 트랜잭션 처리도(Throughput) 등을 고려해야 한다.
- 논리적 설계에서 기술한 트랜잭션의 인터페이스로부터 상세 트렌잭션을 정의한다.

## 7. DB 구현

- DB를 실제로 구축하는 과정
- DB 구현 단계에서는 선정된 DBMS의 DDL로 기술된 명령문을 실행시켜 DB 스키마와 DB 파일을 생성한다. 또한 필요한 경우 DB에 데이터를 입력한다.
- DB 구현 단계에서는 응용 프로그래머에 의해 상세 트랜잭션이 실행 트랜잭션으로 구현된다. 즉 DML로 기술된 명령문을 가지는 프로그램 코드가 작성된다.

# ER (Entity Relationship) 모델

## 1. ER 모델

- 개념적 데이터 모델의 가장 대표적인 것, 1976년 피터 첸(Peter Chen)에 의해 제안되었다.
- 개체, 속성, 관계 등에 대하여 용이하게 표현할 수 있는 ER 도형(ER Diagram)을 정의하고 있다.

## 2. ER 도형

- ER 모델은 몇가지 도형들을 이용하여 현실 세계를 표현한다.
- 사각형 : 개체 타입
- 마름모 : 관계 타입
- 타원 : 속성
- 밑줄 + 타원 : 기본키 속성
- 선분 : 개체 타입과 속성을 연결
- 선분 위의 변수 (1, N, M) : 개체 타입 간의 연관성
- 역삼각형 ISA : ISA 관계

예제 수기

## 3. 개체 및 개체 타입

- 개체는 현실 세계의 객체로서 유형 또는 무형의 정보 대상으로 존재하며 서로 구별될 수 있는 것을 뜻하고 개체의 특성을 나타내는 속성을 갖는다.
- 하나의 개체를 개체 어커런스(Occurrence) 또는 개체 인스턴스(Instance)라 하고, 개체 어커런스들의 집합에 대한 공통의 특성들을 갖는 개체 클래스를 개체 타입이라 한다.

예제 수기

## 4. 관계 및 관계 타입

- 관계는 2개 이상의 개체 사이에 존재하는 연관성을 뜻하며, 관계 타입은 같은 관계들의 집합 또는 틀을 뜻한다.
- 관계는 관계에 참여하는 개체 타입의 개수에 대한 차수(Degree)와 관계에 참여하는 개체 어커런스의 개수에 대한 대응 카디널리티(Mapping Cardinality)를 갖는다.
- 차수에 따른 관계의 종류
  - 단항(Unary) : 관계에 참여하고 있는 개체 타입이 1개
  - 이항(Binary) : 관계에 참여하고 있는 개체 타입이 1개
  - 삼항(Ternary) : 관계에 참여하고 있는 개체 타입이 3개
  - n항(n-ary) : 관계에 참여하고 있는 개체 타입이 n개
- 대응 카디널리티에 따른 관계의 종류
  - 1 : 1 : 관계에 참여하고 있는 두 개체 타입이 모두 하나 씩의 개체 어커런스를 갖는 관계
  - 1 : N : 관계에 참여하고 있는 개체 타입 중 한 개체 타입은 여러 개의 개체 어커런스를 가질 수 있고, 다른 한 개체 타입은 하나의 개체 어커런스를 갖는 관계
  - N : M : 관계에 참여하고 있는 두 개체 타입 모두 여러 개의 개체 어커런스를 가질 수 있는 관계
  - ISA 
    - 같은 속성을 갖는 여러 개체들을 하나의 상위 개체로 결합할 수 있으며, 특정 개체는 서로 구별되는 여러 하위 개체로 나누어 질 수 있따.
    - disjoint : 상위 개체의 멤버가 하나의 하위 개체에만 포함될 때 (사람을 성인과 청소년으로 구분하면 사람은 둘 중 하나에만 속할 수 있다.), overlapping :  여러 하위 개체에 포함될 때 (교직원을 교원과 직원으로 구분하면 동시에 교원이면서 직원인 교직원이 존재할 수 있다.)
    - total : 상위 개체의 멤버가 하위 개체에 속할 때 (사람은 성인이든 청소년이든 반드시 둘 중 하나에 속해야만 한다.), partial : 속하지 않을 때 (사원을 개발팀과 기획팀으로 구분하면 팀이 아직 배정되지 않은 사원도 존재할 수 있다.)

예제 수기

## 5. 속성

- 개체의 특성이나 상태를 기술한 것, 관계 역시 개체와 마찬가지로 속성을 가질 수 있다. (학생이라는 개체는 학번, 이름, 학과 등의 속성을 가질 수 있고, 교수와 학생 개체 간의 지도라는 관계는 강의실, 강의 시간 등의 속성을 가질 수 있다.)
- 속성이 가질 수 있는 모든 가능한 값들의 집합을 도메인이라 한다. (학생이라는 개체가 성별 속성을 가지는 경우, 성별 속성의 도메인은 '남'과 '여'로 제한할 수 있다.)
- 모든 개체 타입은 그 개체를 유일하게 식별해주는 기본 키에 속하는 속성을 포함한다. (학번이라는 속성을 이용하여 학생 개체를 유일하게 식별할 수 있다.)
- 속성에는 더 이상 다른 속성으로 나눌 수 없는 단순 속성과 2개 이상의 속성들로 분해할 수 있는 복합 속성이 있다. (나이라는 속성은 더 이상 쪼갤 수 없지만 주소라는 속성은 시, 군, 구 동 등의 단순 속성으로 쪼개어 표현이 가능하다.)

## 6. 요구 사항을 이용하여 ERD 만들기

1. 요구 사항 명세서에서 현실 세계에 존재하는 유,무형의 개체를 표현하는 명사를 찾아서 ERD 기호에 맞게 개체와 속성을 그린다.
2. 요구 사항 명세서에서 개체를 설명하는 동사를 찾아 개체 사이의 관계를 설정한다.

예제 수기

# 관계형 데이터 모델

데이터를 테이블 또는 릴레이션의 구조로 표현하는 논리적 데이터 모델

## 1. 관계형 데이터 구조 : 릴레이션

- 관계형 데이터 모델에서는 데이터를 원자 값으로 갖는 2차원의 테이블로 표현한다. 이를 릴레이션이라 한다.
- 릴레이션의 구조는 물리적인 저장 구조를 나타내는 것이 아닌 논리적 구조이므로 다양한 정렬 기준을 통하여 릴레이션을 표현할 수 있다.
- 릴레이션은 구조를 나타내는 릴레이션 스키마와 실제 값들인 릴레이션 인스턴스로 구성된다.
- 릴레이션의 열(Column)을 속성이라 하고 행(Row)을 튜플이라 한다.
- 릴레이션에서 하나의 애트리뷰트(속성)가 취할 수 있는 같은 타입의 원자 값들의 집합을 도메인이라고 한다. 도메인은 실제 애트리뷰트 값이 나타날 때 그 값의 합법 여부를 시스템이 검사하는 데에도 이용된다.

예제 수기

## 2. ER 모델을 관계형 데이터 모델로 변환

- 개념적 데이터 모델인 ER 모델을 논리적 데이터 모델인 릴레이션 스키마로 변환하는 것으로, Mapping Rule이라고도 한다.
- ER 도형에서의 개체와 관계는 관계형 데이터 모델에서의 개체 릴레이션과 관계 릴레이션으로 변환하여 표현한다.
- 속성은 컬럼으로, 식별자는 기본키로 표현하고 릴레이션 간의 관계는 기본 키와 이를 참조하는 외래 키를 이용하여 표현한다.
- 개체 A, B와 관계 Y로 이루어진 ER 모델을 관계형 데이터 모델에서의 릴레이션 스키마로 변환하는 과정
  - 개체 A, B는 각각 독립적인 릴레이션 A, B로 표현된다. 또한, ER 도형에서의 각 개체의 속성들은 각 릴레이션의 속성들로 정의되고, 기본 키는 밑줄을 그어 표시한다.
  - 관계 Y가 1 : 1 관계이면, 릴레이션 A의 기본 키를 릴레이션 B의 외래 키로 추가하거나 릴레이션 B의 기본키를 릴레이션 A의 외래 키로 추가하여 표현한다.
  - 관계 Y가 1 : N 관계이면, 릴레이션 A의 기본 키를 릴레이션 B의 외래 키로 추가하여 표현한다.
  - 관계 Y가 N : M 관계이면, 릴레이션 A와 B의 기본 키를 모두 포함한 별도의 릴레이션으로 표현한다. 이 때 생성된 별도의 리레이션을 교차 릴레이션, 교차 엔티티라고 한다.
- 상위 개체 A와 하위 개체 B, C가 ISA 관계로 이루어진 ER 모델을 릴레이션 스키마로 변환하는 방법
  - A 릴레이션의 기본 키를 B와 C 릴레이션의 외래 키로 추가하여 표현한다. 즉 A, B, C 세 개의 릴레이션이 생성된다.
  - A가 가지고 있는 속성과 B, C가 가지고 있는 속성을 각자 결합하여 표현한다. 즉 A 속성을 포함하고 있는 B, C 두 개의 릴레이션이 생성된다.

예제 수기

## * 릴레이션 스키마의 다른 표현

관계형 데이터 모델에서 사용하는릴레이션 스키마를 실무에서는 여러가지 형태로 표기하여 사용한다.

- 속성만 기록한 도형으로 표기
- 속성에 자료형과 크기를 표시한 도형으로 표기
- 정보 공학적 도형을 이용하여 표기하기
  - 파이프 | : 필수(Mandatory)
  - 원 o : 선택적(Optional)
  - < : 다중(Multiple)

예제 수기

## * 식별 / 비식별 관계

- 식별 관계 (Identifying)
  - 개체 A, B 사이의 관계에서 A 개체의 기본 키가 B 개체의 외래 키이면서 동시에 기본 키가 되는 관계
  - B 개체의 존재 여부가 A 개체의 존재 여부에 의존적인 경우에 발생하며, ER 도형에서 식별 관계는 실선으로 표시
- 비식별 관계 (Non-identifying)
  - 개체 A, B 사이의 관계에서 A 개체의 기본 키가 B 개체의 비기본 키 영역에서 외래 키가 되는 관계
  - B 개체의 존재 여부는 A 개체와 관계없이 존재한다.
  - 일반적으로 두 개체는 비식별 관계로 존재하는 경우가 많으며, ER 도형에서 점선으로 표시

예제 수기

## * 테이블 정의서

- 테이블에 대한 자세한 설명과 컬럼에 대하여 정의한 문서로 논리적 데이터 설계 시에 클래스, 시퀀스 다이어그램 등의 문서와 같이 산출
- 표준 양식이 정해져 있지 않지만, 일반적으로 시스템 명, 테이블 ID, 테이블 명, 작성일 및 작성자, 컬럼 ID, 컬럼 명, 자료형, 길이, 키 정보, Nullable 등 테이블에 대한 구체적인 내용을 포함한다.
- 관계형 데이터 모델에서는 테이블 정의서 외에 뷰, 인덱스 등에 대한 정의서도 작성한다.

예제 수기

# 키의 개념 및 종류

키란 DB에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때, 기준이 되는 속성

## 1. 슈퍼 키

- 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키를 말한다. 릴레이션을 구성하는 모든 튜플 중 슈퍼 키로 구성된 속성의 집합과 동일한 값은 나타나지 않는다.
- 릴레이션을 구성하는 모든 튜플에 대해 유일성을 만족한다. (최소성은 관계 없다.)
- (학생 릴레이션에서는 학번, 주민등록번호, (학번, 주민등록번호), (학번, 주민등록번호, 이름) 등이 슈퍼 키가 될 수 있다.)

## 2. 후보 키

- 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해 사용되는 속성들의 부분 집합
- 유일성과 최소성을 모두 만족
- (학생 릴레이션에서는 학번이나 주민등록번호는 유일성과 최소성 둘 다 만족하므로 후보 키가 될 수 있고, 수강 릴레이션에서는 (학번, 과목명)으로 조합해야 유일성과 최소성을 만족하기 때문에 (학번, 과목명)이 후보 키가 된다.)
- (학번, 과목명)과 같이 2개 이상의 필드를 조합하여 만든 키를 복합 키라고 한다.

## 3. 기본 키

- 후보 키 중에서 특별히 선정된 키로 중복된 값을 가질 수 없다.
- 후보 키의 성질을 갖는다.(유일성, 최소성) 튜플을 식별하기 위해 반드시 필요한 키
- Null X (튜플에서 기본 키로 설정된 속성에는 NULL 값이 있어서는 안된다.)

## 4. 대체 키

후보 키 중에서 선정된 기본 키를 제외한 나머지 후보 키

## 5. 외래 키

- 다른 릴레이션의 기본 키를 참조하는 속성 또는 속성들의 집합
- 릴레이션 간의 관계를 표현할 때 사용
- 한 릴레이션에 속한 속성 A와 참조 릴레이션의 기본 키인 B가 동일한 도메인 상에서 정의되었을 때의 속성 A를 외래 키라고 한다.
- 참조 릴레이션의 기본 키와 동일한 키 속성을 가진다.

# 무결성

## 1. 무결성의 개념

- DB에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제 값이 일치하는 정확성
- 무결성 제약 조건 : DB에 저장된 데이터의 정확성을 보장하기 위해 정확하지 않은 데이터가 DB 내에 저장되는 것을 방지하기 위한 제약 조건

## 2. 무결성의 종류

- NULL : 릴레이션의 특정 속성 값이 NULL이 될 수 없도록 하는 규정
- 고유 (Unique) : 릴레이션의 특정 속성에 대해 각 튜플이 갖는 속성 값들이 서로 달라야 한다는 규정
- 도메인 : 특정 속성의 값이 그 속성이 정의된 도메인에 속한 값이어야 한다는 규정
- 키 : 하나의 릴레이션에는 적어도 하나의 키가 존재해야 한다는 규정
- 관계 : 릴레이션에 어느 한 튜플의 삽입 가능 여부 또는 한 릴레이션과 다른 릴레이션의 튜플들 사이의 관계에 대한 적절성 여부를 지정한 규정
- 참조 : 외래 키 값은 NULL이거나 참조 릴레이션의 기본 키 값과 동일해야 한다는 규정
- 개체 : 기본 릴레이션의 기본 키를 구성하는 어떤 속성도 NULL일 수 없다는 규정

# 관계 대수

## 1. 관계 대수의 개념

- 관계형 DB에서 원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 절차적 언어
- 하나 또는 두 개의 릴레이션을 입력으로 받아들여 결과로서 새로운 릴레이션을 생성해내는 연산들의 집합
- 기본 연산 : SELECT, PROJECT, JOIN, DIVISION etc..
- 집합 연산 : UNION, DIFFERENCE, INTERSECTION, CARTESIAN PRODUCT etc...

## 2. 순수 관계 연산자

- SELECT
  - 릴레이션에 존재하는 튜플들 중에서 특정 조건을 만족하는 튜플들의 부분 집합를 구하여 새로운 릴레이션을 만든다.
  - 릴레이션의 행에 해당하는 튜플을 구하는 것이므로 수평 연산이라고도 한다.
  - 연산 기호 : 그리스 문자 시그마 (σ)
  - 조건에서는 기호를 사용한 비교 연산(＜, ＝, ＞, ≠, ≤, ≥ 등)이 허용되며, AND, OR, NOT 등의 논리 연산자를 사용하여 여러 개의 조건들을 하나의 조건으로 결합시킬 수도 있다.
- PROJECT
  - 주어진 릴레이션에서 속성 리스트에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만든다. 단, 연산 결과에 중복이 발생하면 중복이 제거된다.
  - 릴레이션에서 열에 해당하는 속성을 추출하는 것이므로 수직 연산이라고도 한다.
  - 연산 기호 : 그리스 문자 파이 (π)
- JOIN
  - 공통 속성을 중심으로 2개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만든다.
  - 연산의 결과로 만들어진 릴레이션의 차수는 조인된 두 릴레이션의 차수의 합이다.
  - 연산의 결과는 CARTESIAN PRODUCT 연산을 수행한 다음 SELECT 연산을 수행한 것과 같다.
  - 연산 기호 : ▷◁
  - 비교 연산자(＜, ＝, ＞, ≠, ≤, ≥ 등)를 θ로 일반화하여 θ로 표현될 수 있는 조인을 세타 조인(θ-join, Theta JOIN)이라고 한다. (Equi JOIN etc...)
  - 조건이 '='일 때 동일한 속성이 2번 나타나게 되는데, 이 중 중복된 속성을 제거하여 같은 속성은 1번만 나타나게 하는 연산을 자연 조인(NATURAL JOIN)이라 한다.
- DIVISION
  - 두 릴레이션 R(X), S(Y)에 대해 Y⊆X이고 X-Y=Z라고 하면, R(X)와 R(Z, Y)는 동일한 표현이다. 이 때, 릴레이션 R(Z, Y)에 대한 S(Y)의 DIVISION 연산은 S(Y)의 모든 튜플에 연관되어 있는 R(Z)의 튜플을 선택하는 것이다.

예제 수기

## 3. 일반 집합 연산자

- 집합 연산은 수학적 집합 이론에서 사용하는 연산자로서 릴레이션 연산에도 그대로 적용할 수 있다.
- 집합 연산 중 UNION, DIFFERENCE, INTERSECTION을 처리하기 위해서는 합병 조건을 만족해야 한다. (합병 조건 : 합병하려는 두 릴레이션 간에 속성의 수가 같고, 대응되는 속성 별로 도메인이 같아야 한다.)
- 두 릴레이션 R과 S가 있을 때 각 집합 연산의 특징
  - 합집합 (∪ : UNION)
    - 기능 및 수학적 표현
      - 두 릴레이션에 존재하는 튜플의 합집합을 구한다.
      - 결과로 생성된 릴레이션에서 중복되는 튜플은 제거
      - R∪S={t|t∈R ∨ t∈S} // t는 릴레이션 R 또는 S에 존재하는 튜플
    - 카디널리티 : |R∪S| ≤ |R|+ |S| // 합집합의 카디널리티는 두 릴레이션 카디널리티의 합보다 크지 않다.
  - 교집합 (∩ : INTERSECTION)
    - 기능 및 수학적 표현
      - 두 릴레이션에 존재하는 튜플의 교집합을 구한다.
      - R∩S={t|t∈R ∧ t∈S} // t는 릴레이션 R과 S에 동시에 존재하는 튜플
    - 카디널리티 : |R∩S| ≤ Min(|R|, |S|) // 교집합의 카디널리티는 두 릴레이션 중 카디널리티가 적은 릴레이션의 카디널리티보다 크지 않다.
  - 차집합 (- : DIFFERENCE)
    - 기능 및 수학적 표현
      - 두 릴레이션에 존재하는 튜플의 차집합을 구한다.
      - t는 릴레이션 R에만 존재하고 S에는 존재하지 않는 튜플
    - 카디널리티 : |R-S| ≤ |R| // 차집합의 카디널리티는 릴레이션 R의 카디널리티보다 크지 않다.
  - - 
  - 교차곱 (X : CARTESIAN PRODUCT)
    - 기능 및 수학적 표현
      - 두 릴레이션에 존재하는 튜플들의 결합된 정보를 구한다.
      - R X S={r · s|r∈R ∧ s∈S} // r · s는 R에 존재하는 튜플 r과 S에 존재하는 튜플 s를 결합한 튜플
    - 카디널리티 : |R X S| = |R| X |S| // 교차곱의 카디널리티는 두 릴레이션 카디널리티를 곱한 것과 같다.

예제 수기

## 4. 관계 해석 (Relational Calculus)

- 관계 데이터 모델의 제안자인 코드(E. F. Codd)가 수학의 술어 해석(Predicate Calculus)에 기반을 두고 관계 DB를 위해 제안했다.
- 관계 데이터의 연산을 표현하는 방법으로, 원하는 정보를 정의할 때는 계산 수식을 사용
- 관계 해석은 원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성을 지닌다.
- 튜플 관계 해석과 도메인 관계 해석이 있다.
- 기본적으로 관계 해석과 관계 대수는 관계 DB를 처리하는 기능과 능력 면에서 동등하며, 관계 대수를 표현한 식은 관계 해석으로 표현할 수 있다.
- 질의어로 표현

# SQL - DDL

## 1. DDL의 개념

- 스키마, 도메인, 테이블, 뷰, 인덱스를 정의하거나 변경 또는 제거할 때 사용하는 언어
- DDL로 정의된 내용은 메타데이터가 되며, 시스템 카탈로그에 저장한다.
- 유형
  - CREATE : 스키마, 도메인, 테이블, 뷰, 인덱스를 정의
  - ALTER : 테이블에 대한 정의를 변경
  - DROP : 스키마, 도메인, 테이블, 뷰, 트리거, 인덱스를 제거

## 2. CREATE SCHEMA

- 스키마를 정의하는 명령문
- 스키마는 하나의 응용(사용자)에 속하는 테이블과 기타 구성 요소 등을 그룹짓기 위한 것
- 스키마의 식별을 위한 스키마 이름과 해당 스키마의 소유권자나 허가권자를 정의
- CREATE SCHEMA 스키마명 AUTHORIZATION 사용자id;
- CREATE SCHEMA 대학교 AUTHORIZATION 홍길동;
  - ID가 홍길동인 사용자의 스키마 '대학교'를 정의하는 SQL문

## 3. CREATE DOMAIN

- 도메인을 정의하는 명령문
- 도메인이란 하나의 속성이 취할 수 있는 동일한 타입의 원자 값들의 집합
- 임의의 속성에서 취할 수 있는 값의 범위가 SQL에서 지원하는 전체 데이터 타입의 값이 아니고 일부분일 때, 사용자는 그 값의 범위를 도메인으로 정의할 수 있다.
- 정의된 도메인 명은 일반적인 데이터 타입처럼 사용
- CREATE DOMAIN 도메인명 데이터타입 DEFAULT 기본값 CONSTRAINT 제약조건명 CHECK (범위 값);
  - [DEFAULT 기본값]과 [CONSTRAINT 제약조건명 CHECK (범위 값)]은 생략 가능
- CREATE DOMAIN SEX CHAR(1) DEFAULT '남' CONSTRAINT VALID-SEX CHECK (VALUE IN('남', '여'));
  - 성별을 '남' 또는 '여'와 같은 정해진 1개의 문자로 표현되는 도메인 SEX를 정의하는 SQL 문

## * SQL에서 지원하는 기본 데이터 타입

- 정수 (Integer) : INT (4Byte 정수), SMALLINT (2Byte 정수)
- 실수 (Float) : FLOAT, REAL, DOUBLE, PRECISION
- 형식화된 숫자 : DEC(i, j) // i : 전체 자릿수, j : 소수부 자릿수
- 고정길이 문자 : CHAR(n) // n : 문자 수
- 가변길이 문자 : VARCHAR(n) // n : 문자 수
- 고정길이 비트 열 (Bit String) : BIT(n)
- 가변길이 비트 열 : VARBIT(n)
- 날짜 : DATE
- 시간 : TIME

## 4. CREATE TABLE

- 테이블을 정의하는 명령문
- CREATE TABLE 테이블명 속성명 데이터타입 NOT NULL ..., PRIMARY KEY (기본키속성명) ..., UNIQUE (대체키속성명) ..., FOREIGN KEY (외래키속성명) REFERENCES 참조테이블(기본키속성명) ON DELETE 옵션 ON UPDATE 옵션..., CONSTRAINT 제약조건명 CHECK (조건식);
  - 생략 가능 : [NOT NULL], [PRIMARY KEY (기본키속성명)], [UNIQUE (대체키속성명)], [FOREIGN KEY (외래키속성명) REFERENCES 참조테이블(기본키속성명)], [ON DELETE 옵션], [ON UPDATE 옵션], [CONSTRAINT 제약조건명], [CHECK (조건식)]
  - 기본 테이블에 포함될 모든 속성에 대하여 속성명, 속성의 데이터 타입, NOT NULL을 지정
  - PRIMARY KEY : 기본 키로 사용할 속성 또는 속성의 집합을 지정
  - UNIQUE : 대체 키로 사용할 속성 또는 속성의 집합을 지정
  - FOREIGN KEY ~ REFERENCES ~ : 외래 키 속성과 참조 테이블에 관한 정보를 지정, 외래 키가 지정되면 참조 무결성의 CASCADE 법칙이 적용된다.
  - ON DELETE 옵션 : 참조 테이블의 튜플이 삭제되었을 때 기본 테이블에 취해야 할 사항을 지정한다. 옵션에는 NO ACTION, CASCADE, SET NULL, SET DEFAULT가 있다.
  - ON UPDATE 옵션 : 참조 테이블의 참조 속성 값이 변경되었을 때 기본 테이블에 취해야 할 사항을 지정한다. 옵션에는 NO ACTION, CASCADE, SET NULL, SET DEFAULT가 있다.
    - NO ACTION : 참조 테이블에 변화가 있어도 기본 테이블에는 아무런 조치를 취하지 않는다.
    - CASCADE : 참조 테이블의 튜플이 삭제되면 기본 테이블의 관련 튜플도 모두 삭제되고, 속성이 변경되면 관련 튜플의 속성 값도 모두 변경
    - SET NULL : 참조 테이블에 변화가 있으면 기본 테이블의 관련 튜플의 속성 값을 NULL로 변경
    - SET DEFAULT : 참조 테이블에 변화가 있으면 기본 테이블의 관련 튜플의 속성 값을 기본 값으로 변경
  - CONSTRAINT : 제약 조건의 이름을 지정, 이름을 지정할 필요가 없으면 CHECK 절만 사용하여 속성 값에 대한 제약 조건을 명시
  - CHECK : 속성 값에 대한 제약 조건을 지정

예제 수기

## 5. CREATE VIEW

- 뷰는 하나 이상의 기본 테이블로부터 유도되는 이름을 갖는 가상테이블로, CREATE VIEW는 뷰를 정의하는 명령문
- CREATE VIEW 뷰명(속성명 ...) AS SELECT 문;
  - 생략 가능 : [(속성명 ...)]
  - SELECT 문을 서브 쿼리로 사용하여 SELECT 문의 결과로서 뷰를 생성
  - 서브 쿼리인 SELECT 문에는 UNION이나 ORDER BY 절을 사용할 수 없다.
  - 속성 명을 기술하지 않으면 SELECT 문의 속성 명이 자동으로 사용된다.

예제 수기

## 6. CREATE INDEX

- 인덱스는 검색을 빠르게 하기 위해 만든 보조적인 데이터 구조, CREATE INDEX는 인덱스를 정의하는 명령문
- CREATE UNIQUE INDEX 인덱스명 ON 테이블명(속성명 ASC|DESC ...) CLUSTER;
  - 생략 가능 : [UNIQUE], [CLUSTER], [ASC|DESC]
  - UNIQUE
    - 사용된 경우 : 중복 값이 없는 속성으로 인덱스를 생성
    - 생략된 경우 : 중복 값을 허용하는 속성으로 인덱스를 생성
  - 정렬 여부 지정
    - ASC : 오름차순
    - DESC : 내림차순
    - 생략된 경우 : ASC
  - CLUSTER : 지정된 키에 따라 튜플들을 그룹으로 지정하기 위해 사용

예제 수기

## 7. CREATE TRIGGER

- 트리거는 DB 시스템에서 데이터의 입력, 갱신, 삭제 등의 이벤트가 발생할 때마다 자동적으로 수행되는 사용자 정의 프로시저
- 트리거는 SQL의 제약 조건 방법을 통해 명시할 수 없는 무결성 제약 조건을 구현하고, 관련 테이블의 데이터를 일치시킬 때 주로 사용한다.
- CREATE TRIGGER 트리거명 동작시기옵션 동작옵션 ON 테이블명 REFERENCING NEW|OLD TABLE AS 테이블명 FOR EACH ROW WHEN 조건식 트리거 BODY
  - 생략 가능 : [동작시기옵션], [동작옵션], [NEW|OLD]
  - 동작 시기 옵션 : 트리거가 실행될 때를 지정
    - AFTER : 테이블이 변경된 후에 트리거가 실행
    - BEFORE : 테이블이 변경되기 전에 트리거가 실행
  - 동작 옵션 : 트리거가 실행되게 할 작업의 종류를 지정
    - INSERT : 테이블에 새로운 레코드를 삽입할 때 트리거가 실행
    - DELETE : 테이블의 레코드를 삭제할 때 트리거가 실행
    - UPDATE : 테이블의 레코드를 수정할 때 트리거가 실행
  - 테이블 선택 옵션 : 트리거가 적용될 테이블의 종류를 지정
    - NEW : 새로 추가되거나 변경에 참여할 튜플들의 집합(테이블)에 트리거가 적용
    - OLD : 변경된 튜플들의 집합(테이블)에 트리거가 적용
  - WHEN : 트리거가 실행되면서 지켜야할 조건을 지정
  - 트리거 BODY : 트리거의 본문 코드를 입력하는 부분
    - BEGIN으로 시작해서 END로 끝나는데, 적어도 하나 이상의 SQL 문이 있어야 한다. 없으면 오류 발생 
    - 변수에 값을 치환할 때는 예약어 SET을 사용

예제 수기

## 8. ALTER TABLE

- 테이블에 대한 정의를 변경하는 명령문
- ALTER TABLE 테이블명
  - ADD 속성명 데이터타입 [DEFAULT 기본값] : 새로운 속성 추가
  - ALTER 속성명 [SET DEFAULT 기본값] : 속성의 기본 값(Default)을 변경
  - DROP COLUMN 속성명 [CASCADE] : 속성 제거
- ALTER TABLE 학생 ADD 학년 VARCHAR(3);
  - 학생 테이블에 최대 문자 3개로 구성되는 학년 속성을 추가하는 SQL 문

## 9. DROP

- 스키마, 도메인, 테이블, 뷰, 인덱스, 트리거를 제거하는 명령문
- DROP
  - SCHEMA 스키마명 [CASCADE|RESTRICT] : 스키마 제거
  - DOMAIN 도메인명 [CASCADE|RESTRICT] : 도메인 제거
  - TABLE 테이블명 [CASCADE|RESTRICT] : 테이블 제거
  - VIEW 뷰명 [CASCADE|RESTRICT] : 뷰 제거
  - INDEX 인덱스명 [CASCADE|RESTRICT] : 인덱스 제거
  - TRIGGER 트리거명 [CASCADE|RESTRICT] : 트리거 제거
  - CONSTRAINT 제약조건명 : 제약조건 제거
    - CASCADE : 제거할 개체를 참조하는 다른 모든 개체를 함께 제거한다. 즉, 주 테이블의 데이터 제거 시, 각가의 외래 키와 관계를 맺고 있는 모든 데이터를 함께 제거하는 참조 무결성 제약 조건을 설정하기 위해 사용
    - RESTRICT : 다른 개체가 제거할 개체를 참조 중일 경우 제거가 취소된다.
- DROP TABLE 학생 CASCADE;
  - 학생 테이블을 제거 (학생 테이블을 참조하는 모든 데이터들도 함께 제거)

# SQL - SELECT

SELECT 문은 테이블을 구성하는 튜플들 중에서 전체 또는 조건을 만족하는 튜플을 검색하여 주기억장치에 임시 테이블로 구성하는 명령문

## 1. SELECT 문의 일반적인 형식

SELECT PREDICATE 테이블명.속성명 AS 별칭 ... FROM 테이블명 ... WHERE 조건 GROUP BY 속성명 ... HAVING 조건 ORDER BY 속성명 ASC|DESC ...;

- 생략 가능 : [PREDICATE], [테이블명.], [AS 별칭], [WHERE 조건], [GROUP BY 속성명], [HAVING 조건], [ORDER BY 속성명 ASC|DESC]
- SELECT 절
  - PREDICATE : 검색할 튜플을 제한할 목적으로 사용되는 조건
    - ALL : 모든 튜플들을 검색할 때 사용되며, 기본 값
    - DISTINCT : 중복된 튜플 제거할 때 사용
    - DISTINCTROW : 중복된 튜플을 제거하지만, 선택된 속성의 값이 아닌 튜플의 전체 값을 대상으로 할 때 사용
  - 속성 명 : 검색하여 불러올 속성 또는 수식으로서, 2개 이상의 테이블을 대상으로 검색할 때는 '테이블명.속성명'으로 사용된다.
  - AS : 속성 및 연산의 이름을 다른 제목으로 표시하기 위해 사용
- FROM 절 : 검색할 데이터가 들어 있는 테이블 명을 기술
- WHERE 절 : 검색할 조건을 기술한다. 다양한 조건 연산자의 사용이 가능하며, 이 때 각 연산자의 처리 순서는 연산자 우선 순위를 따른다.
- GROUP BY 절 : 특정 속성을 기준으로 그룹화하여 검색할 때 사용한다. 일반적으로 GROUP BY 절은 그룹 함수와 함께 사용한다.
- HAVING 절 : 그룹에 대한 조건을 기술
- ORDER BY 절 :  특정 속성을 기준으로 정렬하여 검색할 때 사용
  - 속성 명 :  정렬의 기준이 되는 속성 명을 기술
  - ASC : 오름차순 정렬(기본 값), DESC : 내림차순 정렬

## * 조건 연산자 / 연산자 우선 순위 / 그룹 함수

- 조건 연산자
  - 비교 연산자 (＜, ＝, ＞, ≠, ≤, ≥)
  - 논리 연산자 (NOT, AND, OR)
  - LIKE 연산자 : 대표 문자를 이용해 지정된 속성의 값이 문자 패턴과 일치하는 튜플을 검색하기 위해 사용
    - *, % : 모든 문자
    - ?, _ : 하나의 문자
    - '#' : 하나의 숫자
- 연산자 우선 순위
  - 산술 > 관계 > 논리
    - 산술 : X, /, +, -
    - 관계 연산자는 우선 순위가 모두 같다.
    - 논리 : NOT, AND, OR
- 그룹 함수
  - COUNT(속성명) : 그룹별 튜플 수를 구하는 함수
  - MAX(속성명) : 그룹별 최대값을 구하는 함수
  - MIN(속성명) : 그룹별 최소값을 구하는 함수
  - SUM(속성명) : 그룹별 합계를 구하는 함수
  - AVG(속성명) : 그룹별 평균을 구하는 함수

## 2. 기본 검색

예제 수기

## 3. 조건 지정 검색

예제 수기

## 4. 정렬

예제 수기

## 5. 그룹 검색

예제 수기

## 6. 하위 질의

예제 수기

## 7. 복수 테이블 검색

예제 수기

## 8. 통합 질의

예제 수기



