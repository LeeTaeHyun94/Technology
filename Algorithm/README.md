# Interval Scheduling

- Earliest start time (Earlist Job First) : 시작 시간이 가장 빠른 작업들로 스케쥴링, 하지만 이는 항상 최적해를 구하지 않는다. 정확하지 않은 알고리즘
- Shortest interval (Shortest Job First) : 가장 짧은 구간(시간이 적게 걸리는)을 가진 작업들로 스케쥴링, 하지만 이 또한 반례가 존재. 항상 최적해를 구할 수 없다.
- Earilest finish time : 작업 종료 시간이 가장 빠른 작업들로 스케쥴링, 몇가지 예시들을 생각해보면 최적이라는 것을 알 수 있다. [증명]

* 스케쥴링 문제의 해는 구간들의 부분집합으로 이루어진다. (Exaustive Scheduling)
  즉, 2^n개의 부분집합 각각 모두를 고려하면 해가 반드시 하나는 존재한다. 하지만 시간복잡도가 커 문제를 해결하는데 시간이 오래걸린다.

-> 이보다 더 빠른 시간 안에 해결할 수 있는가?
   - Earilest finish time (Optimal Scheduling) : 수학적 귀납법으로 재귀적인 증명이 가능하다. 어떤 작업 E를 제외하고 최적의 해인 부분집합 I'이 있다고 생각할 때, (가정)
						 작업 시간이 겹치는 다른 작업들(E, E', E'', ...)과 비교했을 때 가장 먼저 끝나는 작업 E를 포함하는 것이 최적의 해라는 것을 증명하면 된다.

-> 즉, E를 포함하는 부분집합이 최대 구간의 수를 갖는다를 증명!
	: 그렇다면 E를 포함하지 않는 부분집합이 최적의 해가 아니라고 할 때 (E'을 포함한 부분집합이 최적이라면) E를 포함하도록 변형이 가능하다면 이를 증명할 수 있다.
	  E와 E' 작업을 뺀 부분집합은 E와 E'의 작업시간과는 겹치지 않는다. 그러므로 E'을 빼고 E를 포함해도 구간의 수는 똑같이 최적임을 알 수 있다. E를 포함한 부분집합과
	  E' 포함한 부분집합의 구간의 수는 같다는 말.

	  * 쉽게 생각해보면 빨리 시작하는 작업을 고르는 알고리즘과는 다르게 현재 가장 빨리 끝나는 작업(E)을 매 순간에 고르게 됐을 때, 선택된 작업은 시작시간이 어떻게 됐든 간에
	    매 순간에 가장 빨리 끝나는 작업(E)을 고르는 것을 반복했기 때문에 이전에 고른 가장 빨리 끝나는 작업(E') 시간이 현재 고른 가장 빨리 끝나는 작업(E)의 시작 시간보다
	    늦을 수가 없다는 이야기이다. 즉, 가장 빨리 끝나는 작업들을 계속해서 고르게 되면 처리할 수 있는 가장 많은 작업의 수를 고를 수 있다는 것이다.

	  - 시간복잡도는 O(NlogN)에 가능. 1) 입력 데이터를 정렬
	    2) 입력 데이터가 들어올 때마다 힙(Heap) 자료구조에 삽입하여 가장 빨리 끝나는 작업 시간을 가진 데이터가 먼저 pop되도록 구성
	    위의 두 가지 방법이 있다. 이후 각각 작업시간을 비교하여 겹치는지 여부를 확인해주며 최대 처리가능한 작업의 개수를 세면 된다.

>> 심화
 - 작업들에 가중치(비용)이 존재한다면?
 - 장소에 따른 제약조건이 존재한다면?

# Combinatorial Objects (조합 객체)

1. Permutation (순열)
2. Subsets (부분 집합)
3. Trees (트리 / 루트가 있는 트리, 루트가 없는 트리)
4. Graphs (그래프)
5. Points (점)
6. Polygons (다각형)
7. Strings (문자열)

이들은 모두 Recursive Objects (재귀 객체)이다.
1. 순열에서 어떤 원소 하나를 제거하더라도 또 다른 순열을 얻게 된다.
2. 부분 집합에서도 어떤 원소 하나를 제거하더라도 또 다른 부분집합이다.
3. 트리의 루트를 제거하더라도 subtree들로 나뉘어진다. 혹은 단말 노드 하나를 제거하더라도 하나의 작은 트리가 남게 된다.
4. 그래프는 그룹으로도 나눌수 있고 어느 한 정점을 제거해도 작은 그래프가 남는다.
5. 한 무리의 점을 그룹으로 쪼갤 수 있다.
6. n 개의 꼭지점을 가진 단순 다각형에서 서로 인접하지 않은 두 꼭지점을 이어주면 작은 두 다각형으로 나뉘어진다.
7. 문자열에서 어느 한 글자를 지우면 길이 1이 줄어든 문자열이 된다.

재귀적 알고리즘으로 해결 가능한 문제들이라는 말이다.
이처럼 문제를 모델링하는 것이 중요하다.