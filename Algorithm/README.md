[Algorithms]
======================

# 1. Interval Scheduling

## 1.1 다양한 접근법
- Earliest start time (Earlist Job First) : 시작 시간이 가장 빠른 작업들로 스케쥴링, 하지만 이는 항상 최적해를 구하지 않는다. 정확하지 않은 알고리즘
- Shortest interval (Shortest Job First) : 가장 짧은 구간(시간이 적게 걸리는)을 가진 작업들로 스케쥴링, 하지만 이 또한 반례가 존재. 항상 최적해를 구할 수 없다.
- Earilest finish time : 작업 종료 시간이 가장 빠른 작업들로 스케쥴링, 몇가지 예시들을 생각해보면 최적이라는 것을 알 수 있다. [증명 1.2]

```
* 스케쥴링 문제의 해는 구간들의 부분집합으로 이루어진다. (Exaustive Scheduling)
  즉, 2^n개의 부분집합 각각 모두를 고려하면 해가 반드시 하나는 존재한다.
  하지만 시간복잡도가 커 문제를 해결하는데 시간이 오래걸린다.
```

-> 이보다 더 빠른 시간 안에 해결할 수 있는가?
   - Earilest finish time (Optimal Scheduling) : 수학적 귀납법으로 재귀적인 증명이 가능하다. 어떤 작업 E를 제외하고 최적의 해인 부분집합 I'이 있다고 생각할 때, (가정)
						 작업 시간이 겹치는 다른 작업들(E, E', E'', ...)과 비교했을 때 가장 먼저 끝나는 작업 E를 포함하는 것이 최적의 해라는 것을 증명하면 된다.

## 1.2 최적의 접근법에 대한 증명과 고찰
```즉, E를 포함하는 부분집합이 최대 구간의 수를 갖는다를 증명 (최대 구간의 수를 갖는 독립집합) // (독립집합 (Independent Set) : 집합 간에 서로소가 되는 집합)```

: 그렇다면 E를 포함하지 않는 부분집합이 최적의 해가 아니라고 할 때 (E'을 포함한 부분집합이 최적이라면) E를 포함하도록 변형이 가능하다면 이를 증명할 수 있다.
E와 E' 작업을 뺀 부분집합은 E와 E'의 작업시간과는 겹치지 않는다. 그러므로 E'을 빼고 E를 포함해도 구간의 수는 똑같이 최적임을 알 수 있다. E를 포함한 부분집합과
E' 포함한 부분집합의 구간의 수는 같다는 말.

```
* 쉽게 생각해보면 빨리 시작하는 작업을 고르는 알고리즘과는 다르게 현재 가장 빨리 끝나는 작업(E)을 매 순간에 고르게 됐을 때,  
선택된 작업은 시작시간이 어떻게 됐든 간에 매 순간에 가장 빨리 끝나는 작업(E)을 고르는 것을 반복했기 때문에  
이전에 고른 가장 빨리 끝나는 작업(E') 시간이 현재 고른 가장 빨리 끝나는 작업(E)의 시작 시간보다 늦을 수가 없다는 이야기이다.  
즉, 가장 빨리 끝나는 작업들을 계속해서 고르게 되면 처리할 수 있는 가장 많은 작업의 수를 고를 수 있다는 것이다.
```

## 1.3 시간복잡도
- 시간복잡도는 O(NlogN)에 가능.

1) 입력 데이터를 정렬
2) 입력 데이터가 들어올 때마다 힙(Heap) 자료구조에 삽입하여 가장 빨리 끝나는 작업 시간을 가진 데이터가 먼저 pop되도록 구성

위의 두 가지 방법이 있다. 이후 각각 작업시간을 비교하여 겹치는지 여부를 확인해주며 최대 처리가능한 작업의 개수를 세면 된다.

## 1.4 심화

### 1.4.1 작업들에 가중치(비용)이 존재한다면?
: 결론부터 말하면 정점에 가중치가 존재하는 Interval Graph에서 특정한 가중독립집합을 구하는 문제가 된다. // 독립집합 <=> 클릭 (Clique) : 모든 가능한 변이 존재하는 꼭짓점들의 부분집합

모든 부분집합을 탐색할 필요없이 구간들의 관계를 나타내는 방향그래프를 구성한다.

왼쪽에 있는 구간에서 부터 오른쪽에 있는 구간으로 사이클이 없는 방향그래프(Directed Acyclic Graph)로 구성이 된다. // DAG라는 것은 다른 그래프들보다 빠른 시간 안에 해결 가능한 문제로 만들 수 있다는 의미.

위의 DAG를 위상정렬한 뒤, 정점의 가중치의 합이 최대가 되는 최대가중경로를 구하면 된다.
최대가중경로를 구하는 알고리즘은 모든 정점들에서 그 정점을 지나는 순간에 가장 큰 가중치를 가질 때의 값을 배열에 저장한 뒤,
배열에서 가장 큰 값에서 시작하여 역산(정점의 가중치는 빼고 해당 값을 배열에서 찾는 작업의 반복)으로 경로를 구할 수 있다.
구간에 대한 문제를 그래프 문제로 변형하였기 때문에 최악의 경우 O(N^2)의 시간복잡도를 갖는다.

* 조금 더 빠른 시간 안에 문제를 해결할 수 있는가? 다른 방안의 변형이 가능한가?

구간들의 관계를 나타내는 그래프를 전부 구성할 필요가 없다. 왼쪽 끝점 or 오른쪽 끝점을 기준으로 정렬하면 DAG를 구성하여 위상정렬할 필요없이 구간을 순차적으로 볼 수 밖에 없다.  
이것이 라인 스위핑 [Algorithm 2]  
구간을 순차적으로 보면서  
  
1. 겹치는 구간이 아닌지를 확인  
2. 이전 부분집합들 안에서 최대의 가중치의 값만을 따로 저장하여 확인  
3. 각 구간에서 가능한 경우에 대해서 가중치의 합들을 짝(끝점, 가중치의 합)을 지어 가장 먼저 오는 끝점을 기준으로 하는 최소힙에 저장한다. (현재 보고있는 구간의 시작점 좌표가 이전 구간들의 끝점 좌표를 비교하여 겹치는 구간을 확인해주기 위함.)  
4. 반복해서 힙에 push, pop을 반복하여 왼쪽부터 오른쪽 구간까지 모두 확인하여 최대 가중치를 구해주면 된다. 위에 나온 가중치를 합하는 과정에 대한 기록과 역산을 포함하면 경로 또한 구할 수 있다.  
> @ Search Keyword : 구간경로에서 최대가중치를 찾는 알고리즘

### 1.4.2 장소에 따른 제약조건이 존재한다면?

# 2. Line Sweep (Plane Sweep) 평면 소거법

가장 기본적인 라인 스위핑으로는 왼쪽에서 오른쪽 혹은 오른쪽에서 왼쪽으로 진행방향을 잡고 구간을 의미하는 시작점과 끝점들을 확인하며 문제에 맞게 해결하는 알고리즘.

# 3. Binary Search (Parametric Search)

# 4. Bitmasking

# 5. Harmonic number
Hn = $\frac{1}{1}$ + $\frac{1}{2}$ + $\frac{1}{3}$ + ... + $\frac{1}{n}$ = ln(n) + euler's constant  
Hn >= $\intg{1}{n+1}{$\tfrac{dx}{x}$}$  
```
ln(n+1) <= Hn <= ln(n) + 1
```


[Algorithm Design Process]
======================

# Combinatorial Objects (조합 객체)

1. Permutation (순열)
2. Subsets (부분 집합)
3. Trees (트리 / 루트가 있는 트리, 루트가 없는 트리)
4. Graphs (그래프)
5. Points (점)
6. Polygons (다각형)
7. Strings (문자열)

이들은 모두 Recursive Objects (재귀 객체)이다.

1. 순열에서 어떤 원소 하나를 제거하더라도 또 다른 순열을 얻게 된다.
2. 부분 집합에서도 어떤 원소 하나를 제거하더라도 또 다른 부분집합이다.
3. 트리의 루트를 제거하더라도 subtree들로 나뉘어진다. 혹은 단말 노드 하나를 제거하더라도 하나의 작은 트리가 남게 된다.
4. 그래프는 그룹으로도 나눌수 있고 어느 한 정점을 제거해도 작은 그래프가 남는다.
5. 한 무리의 점을 그룹으로 쪼갤 수 있다.
6. n 개의 꼭지점을 가진 단순 다각형에서 서로 인접하지 않은 두 꼭지점을 이어주면 작은 두 다각형으로 나뉘어진다.
7. 문자열에서 어느 한 글자를 지우면 길이 1이 줄어든 문자열이 된다.

```
재귀적 알고리즘으로 해결 가능한 문제들이라는 말이다.
이처럼 문제를 알고리즘을 설계하기 용이하게 모델링하는 것이 중요하다.
```